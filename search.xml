<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>字节TikTok客户端开发三面</title>
    <url>/2022/03/08/%E5%AD%97%E8%8A%82TikTok%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%89%E9%9D%A2/</url>
    <content><![CDATA[<p>已通过</p>
<hr>
<ul>
<li><p>自我介绍</p>
</li>
<li><p>问了编译器项目</p>
</li>
<li><p>着重问了那个超声的科研项目</p>
<p>系统的设计啊、遇到的困难啊、解决的方案啊</p>
</li>
<li><p>马斯克的星链计划</p>
<p>如果要实现地球的全覆盖至少需要几个卫星（答得不好）</p>
</li>
<li><p>从之前面试官问过的问题里找一些问题重新问</p>
<ul>
<li>重新问了一面的大鱼吃小鱼的问题，问一开始回答的思路是啥，以及回去之后有没有思考更优的算法</li>
<li>假设题目变化，大鱼吃了小鱼之后变大了，上述算法还可用吗</li>
</ul>
</li>
<li><p>曾经遇到的困难</p>
<ul>
<li>讲了搞科研、写论文以及实习之间的困难</li>
</ul>
</li>
<li><p>从我github里找了一个很久之前fork的版本一键更新仓库，然后问到了抖音更新问题</p>
<ul>
<li>用户打开APP时弹窗版本更新是怎么实现的</li>
<li>用户正在使用APP时怎么通知更新</li>
<li>问了很多客户端和服务端http通信的问题</li>
<li>tcp长链接短连接</li>
<li>http是双攻的还是半工的</li>
<li>socket</li>
</ul>
</li>
<li><p>设计一个APP需要考虑哪些部分</p>
<ul>
<li>答了UI、客户端编程、后台数据库、前后端之间的通信</li>
</ul>
</li>
<li><p>介绍自己开发的APP</p>
<ul>
<li>三个大创的APP，然后主要选了那个请假APP介绍</li>
</ul>
</li>
<li><p>开发APP时是怎么去学习的</p>
<ul>
<li>用到啥学啥，举了开发的位置模拟APP的例子</li>
</ul>
</li>
<li><p>activity是啥</p>
</li>
<li><p>介绍了飞书的一个黑科技，进入一个房间会电脑可以自动连上这个房间的投屏，问是怎么实现的</p>
<ul>
<li><p>诶，这个答得不好，说了半天wifi、NFC、蓝牙之类的，愣是没想起来自己做的超声，麻了</p>
</li>
<li><p>面试官提醒超声之后问怎么实现的</p>
</li>
</ul>
</li>
<li><p>对安卓开发的兴趣，后续是否愿意从事这个方向</p>
</li>
<li><p>安卓开发后续的学习规划</p>
</li>
<li><p>问了实习的计划，从几月到几月</p>
</li>
<li><p>反问环节</p>
<ul>
<li>问了一下实习生去了之后干什么，能学到什么？</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>字节TikTok客户端开发二面</title>
    <url>/2022/03/04/%E5%AD%97%E8%8A%82TikTok%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91%E4%BA%8C%E9%9D%A2/</url>
    <content><![CDATA[<p>已通过</p>
<hr>
<ul>
<li><p>上来先聊了一会儿，问了读研几，啥时候毕业之类的。还问了实习安排，能实习多久之类的。</p>
</li>
<li><p>简单自我介绍</p>
</li>
<li><p>稍微讲了一下项目</p>
<ul>
<li>接着项目问的什么是抽象语法树?</li>
<li>抽象语法树的作用，为什么要用抽象语法树？</li>
</ul>
</li>
<li><p>提问（问的问题都好难）</p>
<ul>
<li>语法tang了解过吗？（我连哪个tang都不知道。。）</li>
<li>java编译后的产物，字节码之类的知道多少。（不知道。。表示对java不是很了解）</li>
<li>c++里的多态，虚函数怎么实现的（看我不懂java，想了一会儿问的c++的问题，感觉这是全场唯一一个能正常回答出来的问题）</li>
<li>动态代理？（不知道。。）</li>
<li>systemcall了解吗，为什么会有系统调用？（答了一些内核态和用户态相关的东西）</li>
<li>具体的系统调用有哪些，具体是怎么执行的？（盲猜了一个c++里面的sleep函数，具体咋执行的乱答了继承阻塞之类的。。）</li>
<li>文件描述符（不是很了解，乱答了一些文件的唯一标识，记录文件状态之类的）</li>
<li>一个文件可以有两个文件标识符吗？（不知道）</li>
<li>CDN了解吗？（不了解）</li>
<li>解释了一通CDN，问CDN存在的意义或者作用是啥？（一开始理解成用户可以把数据保存在CDN上可以把连接共享给别人，结果理解错了，面试官又解释了一下一般是服务商把资源放在CDN上供用户访问，问这样做有什么作用。想了一会儿答了本来要访问服务器的请求转到CDN上了，可以用来缓解服务器压力之类和分流之类的，然后感觉和云边端服务器有点像有聊了一大堆云边端的东西，比如提高访问性能啊之类的）</li>
<li>如果CDN上的一个资源不见了，用户访问会怎么办？（不知道。。乱聊了一些设计一个表记录资源是否存在，没有资源了就告诉用户无法访问）</li>
<li>还是上一个问题，有没有别的办法？（不知道。。又乱聊了一些CDN如果发现资源不存在就向服务器请求重新发送资源，好像聊对了，面试官说这叫CDN回源）</li>
<li>然后就问了回源还有啥别的作用？（不知道。。）</li>
<li>除了http还了解过其他不常见的协议吗？（不知道，表示只了解过ftp，ssh之类常见的协议）</li>
<li>QUIC协议了解过吗？（惊了，才看的，答了一下是谷歌做的UDP的升级版，http3.0之后使用的协议，利用udp不需要建立连接解决了tcp握手比较慢的问题，在udp基础上增加重传和拥塞控制等功能保证了可靠性。因为了解的不深说的都很肤浅，面试官反应还行。）</li>
<li>对kotlin有了解吗？（没接触过。。）</li>
<li>对安卓开发有了解吗，做过项目吗？（有一点了解，大学做过几个app）</li>
<li>讲一下做的安卓项目。（讲了个模拟请假的app，听到我说后来全校都在用面试官笑了。）</li>
</ul>
</li>
<li><p>算法题</p>
<p>给一个正整数组nums和一个数字N，每次都从数组头部或者尾部取出一个数字从N中减掉，问最少需要多少使N变为0，如果不能变为0则输出-1。</p>
<ul>
<li><p>想了一会儿先给了个暴力解。</p>
<p>最后的结果一定是从数组前面取出一段加上从数组后面取出一段，这两段的和是N。所以最简单的做法是先计算前缀和以及后缀和，然后n^2暴力，对于每一个前缀和找有没有一个合适的后缀和使二者的和为N，如果有则用二者的长度更新ans。</p>
</li>
<li><p>面试官表示这个方案应该可以解决，但是能不能优化？</p>
<p>想了个优化方案复杂度优化到了O(nlogn)。之前的方案复杂度主要在对于每一个前缀和都要枚举遍历每一个后缀和，而因为都是正整数，所以后缀和是具有单调性的，所以可以用二分的方式找有没有这个前缀和匹配的后缀和。</p>
</li>
<li><p>面试官表示可以，但感觉我的解法跟他想的不一样，又说了一下这个题相当于有两个指针啥的，一个指向前一段，一个指向后一段</p>
<p>面试官说道这里突然悟道他的的意思了。。这题可以反过来想，假设整个数组的和为M，这题其实就相当于从数组里找一段使其和为M-N，然后就没了。。</p>
</li>
<li><p>面试官说那写出来吧。然后看面试官的表情确定这就是他想要的方法。</p>
<p>我就写了个最复杂的方法。枚举子数组的头尾，然后对数组求和看是否等于M-N，连前缀和都没写，复杂度O(n^3)。。</p>
</li>
<li><p>问哪里可以优化？</p>
<p>第三层for循环可以用前缀和替换，优化到O(n^2)。然后就结束了。。</p>
<p>但是这个方法明明没有我刚刚说的那个二分的复杂度低呀。。。</p>
</li>
</ul>
</li>
<li><p>顺便问一下英语怎么样啊？敢说吗？（我笑了，表示还行吧，无障碍交流做不到，听懂应该差不多。。感觉要gg）</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>字节TikTok客户端开发一面</title>
    <url>/2022/02/25/%E5%AD%97%E8%8A%82TikTok%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>已通过</p>
<hr>
<ol>
<li><p>自我介绍</p>
</li>
<li><p>问项目</p>
</li>
<li><p>问基础知识</p>
<ul>
<li><p>虚拟内存是什么有什么用？（因为我在项目提到了内存缺页算法LRU）</p>
</li>
<li><p>函数调用是怎么实现的？（因为我项目有编译器，就回答了一下栈结构，函数参数返回值压栈弹栈之类的，细节忘了）</p>
</li>
<li><p>堆、栈、寄存器哪些是线程独有的，哪些事线程共享的？（不会，想了一会儿回答寄存器肯定是独有的因为涉及到CPU环境切换，堆栈不确定，又想了一下回答了堆栈也是独有的，他说好的没关系，应该是答错了。。）</p>
</li>
<li><p>两个线程都执行a++100次，a的结果是多少？（犹豫了半天还是说了200，感觉不能这么简单吧）</p>
<p>   答案应该是2~200（<a href="https://blog.csdn.net/speargod/article/details/96651069%EF%BC%89">https://blog.csdn.net/speargod/article/details/96651069）</a></p>
</li>
<li><p>tcp四次挥手为什么比三次握手多一次？（服务器要把没传完的数据传完才能再发起FIN请求）</p>
</li>
<li><p>网络拥塞、拥塞控制、流量控制相关知识。</p>
</li>
<li><p>打开一个网页的过程？（主要回答了域名解析的过程）</p>
</li>
<li><p>https和http的区别？（加了个SSL实现加密传输）</p>
</li>
<li><p>SSL是怎么实现加密传输的？（大概说了一下，先用非对称加密交换通信秘钥，然后用通信秘钥进行对称加密通信）</p>
</li>
<li><p>http的错误码？（不怎么了解，看我皱了下眉头就说没关系不问了）</p>
</li>
<li><p>数据库里的事务是什么？</p>
</li>
<li><p>用户输入密码怎么保证安全？（没搞懂他想问的是什么。。）</p>
</li>
<li><p>讨论：用户在PC登陆微信时，可以用手机扫码登陆，这是怎么实现的，想聊什么聊什么。</p>
</li>
</ul>
</li>
<li><p>算法题</p>
<p> 大鱼吃小鱼问题</p>
<p> 一个数字序列，每个元素都代表一条鱼，正数表示鱼向右游，负数表示向左游，数字的绝对值代表鱼的体积，如果两条鱼相撞则大鱼会吃掉小鱼，如果相撞的两条鱼大小相等则都会死亡。鱼游的速度都相同，问最后剩下哪些鱼？</p>
<p> 写了个n^2的暴力算法，应该还可以优化。。最后简单说了一下优化的思路，细节没想清楚也不确定对不对，面试官就说差不多了，没有让继续写下去。</p>
<pre><code> 优化思路：

 开一个数组记录鱼的存活状态，初始值是全true。

 从左往右遍历的时候记录一个值表示往右游的鱼的最大值，遇到一个往右游的就更新一下最大值，遇到一个往左游的就比较大小。
 
 如果往左游的小那就被吃掉，反之认为左边所有往右游的鱼都会被这条往左游的鱼吃掉（因为最大的都比它小），则将最大值置为0继续往右遍历，一直遍历到结尾。
 
 然后从右往左反方向遍历一遍，做同样的操作。
</code></pre>
</li>
</ol>
<p>面试官是真的好，很和善，会引导你回答问题。</p>
<hr>
<ul>
<li><p>堆、栈、寄存器哪些是线程独有的，哪些事线程共享的？</p>
<p>  堆：是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。</p>
<p>  栈：是个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是　thread safe的。操作系统在切换线程的时候会自动的切换栈，就是切换　ＳＳ／ＥＳＰ寄存器。栈空间不需要在高级语言里面显式的分配和释放。</p>
<p>  寄存器这里不太确定，因为寄存器数量是有限的，所以每个线程在执行时应该用的都是这些寄存器，所以从这个角度来说好像是共享的。但是每个线程执行时寄存器的内容是不能被别的线程访问的，所以应该又是独有的。。。总的来说寄存器应该是独有的吧。。。</p>
</li>
<li><p>函数调用是怎么实现的？</p>
<p>  <img src="https://s2.loli.net/2022/02/25/JiwD2eYr3mauVRB.png" alt="20220225184710"></p>
<p>  栈帧，也就是stack frame，其本质就是一种栈，只是这种栈专门用于保存函数调用过程中的各种信息（参数，返回地址，本地变量等）。栈帧有栈顶和栈底之分，其中栈顶的地址最低，栈底的地址最高，SP(栈指针)就是一直指向栈顶的。在x86-32bit中，我们用 %ebp 指向栈底，也就是基址指针；用 %esp 指向栈顶，也就是栈指针。下面是一个栈帧的示意图：</p>
<p>  <img src="https://s2.loli.net/2022/02/25/Zc64pXHNOBilwMu.png" alt="20220225185759"></p>
<p>  一般来说，我们将 %ebp 到 %esp 之间区域当做栈帧（也有人认为该从函数参数开始，不过这不影响分析）。并不是整个栈空间只有一个栈帧，每调用一个函数，就会生成一个新的栈帧。在函数调用过程中，我们将调用函数的函数称为“调用者(caller)”，将被调用的函数称为“被调用者(callee)”。在这个过程中，1）“调用者”需要知道在哪里获取“被调用者”返回的值；2）“被调用者”需要知道传入的参数在哪里，3）返回的地址在哪里。同时，我们需要保证在“被调用者”返回后，%ebp, %esp 等寄存器的值应该和调用前一致。因此，我们需要使用栈来保存这些数据。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针</title>
    <url>/2022/03/17/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-1/</url>
    <content><![CDATA[<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>多个shared_pt智能指针可以使用同一块堆内存，并且该类型只能指针在实现上采用的是引用计数机制。</p>
<p>即使有一个shared_ptr放弃了堆内存的使用权 （引用计数减1） 也不会影响其他shared_ptr的使用 只有引用计数为0 堆内存才会释放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_shared_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* _count;</span><br><span class="line">    T* _ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">my_shared_ptr</span>(T* ptr=<span class="literal">nullptr</span>)&#123; <span class="comment">// 构造函数，默认参数</span></span><br><span class="line">        _ptr = ptr;</span><br><span class="line">        _count = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(_ptr)&#123;</span><br><span class="line">            _count = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">my_shared_ptr</span>()&#123; <span class="comment">// 析构函数</span></span><br><span class="line">        <span class="keyword">if</span>(_ptr&amp;&amp; --(*_count)==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">my_shared_ptr</span>(<span class="keyword">const</span> my_shared_ptr&lt;T&gt;&amp; a)&#123; <span class="comment">// 拷贝构造函数</span></span><br><span class="line">        _ptr = a._ptr;</span><br><span class="line">        _count = a._count;</span><br><span class="line">        <span class="keyword">if</span>(_ptr)&#123;</span><br><span class="line">            (*_count) ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    my_shared_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> my_shared_ptr&lt;T&gt;&amp; a)&#123; <span class="comment">// 赋值运算符</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;a)&#123;</span><br><span class="line">            <span class="keyword">if</span>(_ptr &amp;&amp; --(*_count)==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">delete</span> _ptr;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _ptr = a._ptr;</span><br><span class="line">            _count = a._count;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(_ptr)&#123;</span><br><span class="line">                (*_count) ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *_count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>c++11虽然将weak_ptr指针定为智能指针的一种，但是该类型指针通常不单独使用（没有实际用处）</p>
<p>只能和share_ptr类型指针搭配使用，甚至我们将weak_ptr视为shared_ptr的一个辅助工具</p>
<p>借助weak_ptr指针我们可以获得shared_ptr指针的一些状态信息</p>
<p>比如有多少指向相同的shared_ptr指针，share_ptr指针指向的堆内存是否释放等等</p>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>unique_ptr也具备“在适当的时机自动释放堆内内存空间”的能力</p>
<p>和shared_ptr最大的不同之处就是在于 unique_ptr指针指向的堆内存无法将其与其他unique_str共享</p>
<p>也就是说unique_ptr指针都独自拥有对其所指堆内存空间的所有权</p>
<p>这也就是说 每个unique_str指针指向的堆内存空间的引用计数就是只能为1</p>
<p>一旦该unique_ptr指针放弃所致堆内存空间的所有权，该空间会被立即释放回收</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_unique_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">my_unique_ptr</span>(T* ptr=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        _ptr = ptr;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">my_unique_ptr</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(_ptr)&#123;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">            _ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">my_unique_ptr</span>(<span class="keyword">const</span> my_unique_ptr&lt;T&gt; &amp;a) = <span class="keyword">delete</span>;</span><br><span class="line">    my_unique_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> my_unique_ptr&lt;T&gt; &amp;a) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>华为无线网二面</title>
    <url>/2022/03/16/%E5%8D%8E%E4%B8%BA%E6%97%A0%E7%BA%BF%E7%BD%91%E4%BA%8C%E9%9D%A2/</url>
    <content><![CDATA[<ul>
<li>业务面</li>
<li>先自我介绍</li>
<li>面试官表示对超声波的项目很感兴趣，让详细介绍一下<ul>
<li>大概说了一下应用场景，系统组成，难点和算法之类的</li>
</ul>
</li>
<li>又让介绍了编译器项目<ul>
<li>主要问了还可以有哪些优化方向，说了字符串匹配换成字典树，使用更好的编译器优化算法</li>
</ul>
</li>
<li>未来的发展规划</li>
<li>对城市的倾向性</li>
<li>还面了哪些其它公司</li>
<li>反问环节<ul>
<li>问了面试流程和进度</li>
</ul>
</li>
<li>最后介绍部门是干啥的<ul>
<li>通信，嵌入式开发，5G标准研发，设计芯片，通信协议</li>
<li>产品主要是基站上面的数字信号处理</li>
<li>介绍了好久好久，什么美国打压，未来前景，美国5G行业影响力下降</li>
<li>行业倾向性</li>
</ul>
</li>
</ul>
<p>一共就面了半个小时，后面没有别的面试流程了，面试官表示他应该就可以给出最终的结果。</p>
]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>华为无线网一面</title>
    <url>/2022/03/16/%E5%8D%8E%E4%B8%BA%E6%97%A0%E7%BA%BF%E7%BD%91%E4%B8%80%E9%9D%A2/</url>
    <content><![CDATA[<p>hr发微信通知技术面结束了，一会儿进行综合面，一会儿。。。。</p>
<hr>
<ul>
<li>技术面</li>
<li>上来先问了一下在学校干什么，介绍了一下科研方向</li>
<li>然后直接撕了一道代码，还不是线上IDE，还好我笔记本里有本科时用过的codeblocks。。<ul>
<li>题目：一个字符串，全部是英文字母组成，将其全排列有多少种可能。</li>
<li>先说了思路，感觉像是一道数学题，排列组合之类的，面试官让写一下</li>
<li>写的时候有仔细想了一下，好像当数学题做不太现实，就又想了个回溯的算法</li>
<li>用了五分钟左右写完回溯，跑了两个样例过了</li>
<li>面试官说回溯算法字符串如果很长解决不了，有没有什么优化办法</li>
<li>想了能有三五分钟，面试官说可以了，自己回去再想想吧，然后面试就结束了</li>
<li>一共就免了20分钟，感觉面试官对我的算法不满意，给我挂了</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>字节TikTok客户端开发hr面</title>
    <url>/2022/03/15/%E5%AD%97%E8%8A%82TikTok%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91hr%E9%9D%A2/</url>
    <content><![CDATA[<p>已OC</p>
<hr>
<ul>
<li>实习可以任何时间过去，不一定非得暑假</li>
<li>实习时长有要求（感觉三个月应该是可以的）</li>
<li>工资400/天</li>
<li>5000以上收税，不过60000以下好像会退税</li>
<li>1000房补，要在公司附近租房</li>
<li>有免费三餐</li>
<li>部门是TikTok基础业务部门</li>
<li>安卓和iOS之后可能要选择一个方向</li>
<li>问了有没有其它的offer，都什么部门，到哪一步了</li>
<li>问了个人意向，会作何选择</li>
<li>能保证的大概有7 8 9三个月实习时间</li>
<li>hr小姐姐说话声音真好听~~</li>
</ul>
]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯微信客户端开发二面</title>
    <url>/2022/03/15/%E8%85%BE%E8%AE%AF%E5%BE%AE%E4%BF%A1%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91%E4%BA%8C%E9%9D%A2/</url>
    <content><![CDATA[<p>已挂</p>
<hr>
<p>稍微总结以下挂的原因吧：</p>
<p>首先就是二面的面试形式确实也没见过，面试的主要内容是让自己去讲项目，可能项目梳理的不够清晰以及项目内的技术难点没有达到面试官的要求，总体来说面试官应该是觉得我的项目都比较简单。</p>
<p>然后同样的简历和项目我在tiktok那边是通过了的，而且还是高分通过，结果在腾讯这里二面挂了。其实腾讯一面表现也还行，三道算法题也算是做出来了，知识点项目啥的回答的也凑合，所以主要的问题应该还是处在二面将项目上了。可能微信确实比较难进吧，跟腾讯其它部门比起来微信应算是比较好的部门了，同时横向跟其它大厂的客户端开发比较的话，微信应该也是最好的了，所以可能对员工哪怕是实习生的要求都比较高吧。</p>
<p>还有就是腾讯今年裁员，虽然好像是教育方向的，但是内部好像确实在锁hc。虽然锁hc好像跟实习生没太大关系，但可能还是有点儿影响的。</p>
<hr>
<ul>
<li><p>上来先介绍了一下面试规则和内容，主要就是聊项目，而且主要是由我自己讲。</p>
</li>
<li><p>因为面试官说可以讲一下自己做的比较有成就感的东西，我就先讲了那个请假的APP。根据前几次面试经验，一般讲完这个项目面试官都会感觉挺有趣的，因为全校都在用，很有说服力，不太会在意技术细节。但是这次讲完感觉面试官不太满意，主要是觉得没有技术难度，而且后续也没什么升级，总体来说感觉比较简单吧。</p>
</li>
<li><p>然后面试官让讲一下有点儿技术难度的项目，方便讨论技术细节。然后我就讲了编译器的项目，之前面试都是由面试官提问主导的，所以感觉还行，但是这次面试官完全让我自己从头到尾讲，感觉讲起来就很费劲。然后具体讨论了编译器的每一个步骤的细节和难点，感觉还是技术难点方面不太够，唯一能算技术难点的函数调用压栈出栈和编译器优化，感觉面试官也不太满意。问了一下其它优化有没有做，我都没有。。</p>
</li>
<li><p>讲完两个项目还有时间，又讲了科研项目，讲完感觉面试官的反应也是平平淡淡。</p>
</li>
<li><p>反问环节</p>
<ul>
<li>问了面试的流程</li>
</ul>
</li>
</ul>
<p>整个复试都在聊项目，而且聊的都不咋地，感觉又要g了。。</p>
]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>左值与右值</title>
    <url>/2022/03/15/%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC/</url>
    <content><![CDATA[<h2 id="左值与左值引用"><a href="#左值与左值引用" class="headerlink" title="左值与左值引用"></a>左值与左值引用</h2><h3 id="左值"><a href="#左值" class="headerlink" title="左值"></a>左值</h3><p>左值就是在内存中有确定存储位置，有变量名，表达式结束后依然存在的值。</p>
<h3 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h3><p>左值引用就是绑定到左值上的引用。</p>
<h3 id="左值引用的绑定"><a href="#左值引用的绑定" class="headerlink" title="左值引用的绑定"></a>左值引用的绑定</h3><p>非常量左值引用只能绑定到非常量左值上；</p>
<p>常量左值引用可以绑定到非常量左值、常量左值、非常量右值、常量右值等所有的值类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;              <span class="comment">//非常量左值（有确定存储地址，也有变量名）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a1=<span class="number">10</span>;       <span class="comment">//常量左值（有确定存储地址，也有变量名）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a2=<span class="number">20</span>;       <span class="comment">//常量左值（有确定存储地址，也有变量名）</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//非常量左值引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;b1=a;            <span class="comment">//正确，a是一个非常量左值，可以被非常量左值引用绑定</span></span><br><span class="line"><span class="keyword">int</span> &amp;b2=a1;           <span class="comment">//错误，a1是一个常量左值，不可以被非常量左值引用绑定</span></span><br><span class="line"><span class="keyword">int</span> &amp;b3=<span class="number">10</span>;           <span class="comment">//错误，10是一个非常量右值，不可以被非常量左值引用绑定</span></span><br><span class="line"><span class="keyword">int</span> &amp;b4=a1+a2;        <span class="comment">//错误，（a1+a2）是一个常量右值，不可以被非常量左值引用绑定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常量左值引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;c1=a;      <span class="comment">//正确，a是一个非常量左值，可以被非常量右值引用绑定</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;c2=a1;     <span class="comment">//正确，a1是一个常量左值，可以被非常量右值引用绑定</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;c3=a+a1;   <span class="comment">//正确，（a+a1）是一个非常量右值，可以被常量左值引用绑定</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;c4=a1+a2;  <span class="comment">//正确，（a1+a2）是一个常量右值，可以被常量左值引用绑定</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="右值与右值引用"><a href="#右值与右值引用" class="headerlink" title="右值与右值引用"></a>右值与右值引用</h2><h3 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h3><p>右值就是在内存没有确定存储地址、没有变量名，表达式结束就会销毁的值。</p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>右值引用就是在内存中没有确定存储位置，没有变量名，表达式结束后就会销毁的值。</p>
<h3 id="右值引用的绑定"><a href="#右值引用的绑定" class="headerlink" title="右值引用的绑定"></a>右值引用的绑定</h3><p>非常量右值引用只能绑定到非常量右值上；</p>
<p>常量右值引用可以绑定到非常量右值、常量右值上。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;             <span class="comment">//非常量左值（有确定存储地址，也有变量名）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a1=<span class="number">20</span>;      <span class="comment">//常量左值（有确定存储地址，也有变量名）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a2=<span class="number">20</span>;      <span class="comment">//常量左值（有确定存储地址，也有变量名）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非常量右值引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;b1=a;            <span class="comment">//错误，a是一个非常量左值，不可以被非常量右值引用绑定</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;b2=a1;           <span class="comment">//错误,a1是一个常量左值，不可以被非常量右值引用绑定</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;b3=<span class="number">10</span>;           <span class="comment">//正确，10是一个非常量右值，可以被非常量右值引用绑定</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;b4=a1+a2;        <span class="comment">//错误,（a1+a2）是一个常量右值，不可以被非常量右值引用绑定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常量右值引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;&amp;c1=a;      <span class="comment">//错误，a是一个非常量左值，不可以被常量右值引用绑定</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;&amp;c2=a1;     <span class="comment">//错误,a1是一个常量左值，不可以被常量右值引用绑定</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;&amp;c3=a+a1;   <span class="comment">//正确，（a+a1）是一个非常量右值，可以被常量右值引用绑定</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;&amp;c4=a1+a2;  <span class="comment">//正确,（a1+a2）是一个常量右值，可以被常量右值引用绑定</span></span><br></pre></td></tr></table></figure>

<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol>
<li><p>左值引用绑定到有确定存储空间以及变量名的对象上，表达式结束后对象依然存在；右值引用绑定到要求转换的表达式、字面常量、返回右值的表达式等临时对象上，赋值表达式结束后就对象就会被销毁。</p>
</li>
<li><p>左值引用后可以利用别名修改左值对象；右值引用绑定的值不能修改。</p>
</li>
</ol>
<h2 id="move函数"><a href="#move函数" class="headerlink" title="move函数"></a>move函数</h2><p>从上述可以发现，常量左值引用可以绑定到右值上，但右值引用不能绑定任何类型的左值，若想利用右值引用绑定左值该怎么办呢？<br>C++11中提供了一个标准库move函数获得绑定到左值上的右值引用，即直接调用std::move告诉编译器将左值像对待同类型右值一样处理，但是被调用后的左值将不能再被使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;                 <span class="comment">//非常量左值（有确定存储地址，也有变量名）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a1=<span class="number">20</span>;          <span class="comment">//常量左值（有确定存储地址，也有变量名）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非常量右值引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;d1=std::<span class="built_in">move</span>(a);    <span class="comment">//正确，将非常量左值a转换为非常量右值，可以被非常量右值引用绑定</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;d2=std::<span class="built_in">move</span>(a1);    <span class="comment">//错误,将常量左值a1转换为常量右值，不可以被非常量右值引用绑定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常量右值引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;&amp;c1=std::<span class="built_in">move</span>(a);      <span class="comment">//正确，将非常量左值a转换为非常量右值，可以被常量右值引用绑定</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;&amp;c2=std::<span class="built_in">move</span>(a1);     <span class="comment">//正确,将常量左值a1转换为常量右值，可以被常量右值引用绑定</span></span><br></pre></td></tr></table></figure>

<h2 id="引入右值引用的原因"><a href="#引入右值引用的原因" class="headerlink" title="引入右值引用的原因"></a>引入右值引用的原因</h2><ol>
<li><p>替代需要销毁对象的拷贝，提高效率：某些情况下，需要拷贝一个对象然后将其销毁，如：临时类对象的拷贝就要先将旧内存的资源拷贝到新内存，然后释放旧内存，引入右值引用后，就可以让新对象直接使用旧内存并且销毁原对象，这样就减少了内存和运算资源的使用，从而提高了运行效率；</p>
</li>
<li><p>移动含有不能共享资源的类对象：像IO、unique_ptr这样的类包含不能被共享的资源（如：IO缓冲、指针），因此，这些类对象不能拷贝但可以移动。这种情况，需要先调用std::move将左值强制转换为右值，再进行右值引用。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>简历</title>
    <url>/2022/03/12/CV/</url>
    <content><![CDATA[<div class="pdfobject-container" data-target="/CV.pdf" data-height="1000px"></div>
]]></content>
      <tags>
        <tag>简历</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云游戏一点五面</title>
    <url>/2022/03/11/%E9%98%BF%E9%87%8C%E4%BA%91%E6%B8%B8%E6%88%8F%E4%B8%80%E7%82%B9%E4%BA%94%E9%9D%A2/</url>
    <content><![CDATA[<ul>
<li>自我介绍</li>
<li>华为实习工作<ul>
<li>问了开发过哪些规则</li>
<li>定义变量没有初始化会发生生么事</li>
</ul>
</li>
<li>对写代码怎么看<ul>
<li>对35岁还在写代码没什么出息怎么看</li>
</ul>
</li>
<li>自己的规划<ul>
<li>5年内的规划</li>
</ul>
</li>
<li>觉得哪个项目有亮点<ul>
<li>讲了编译器的项目</li>
<li>项目由哪几个模块组成，有哪些难点</li>
</ul>
</li>
<li>对编译原理的理解</li>
<li>对业务和技术的看法以及倾向<ul>
<li>抖音电商的offer和阿里云编译的offer选哪个</li>
</ul>
</li>
<li>对硬件和芯片的看法和兴趣</li>
<li>ACM竞赛的经历<ul>
<li>比赛的过程是什么样子</li>
<li>做了哪些贡献</li>
<li>有什么收获</li>
</ul>
</li>
<li>反问环节<ul>
<li>问了面试的进度是什么样子，因为后台看不到</li>
</ul>
</li>
</ul>
<p>总结：一共差不多30分钟，没问太多八股文，主要是问了项目实习以及聊了一些规划和看法之类的。上一次不算一面，只算做意向评估，这次的能算一面吧，后面还有一到两轮技术面，还要HR面，以及笔试挺难的也挺重要的。认为我的优势是ACM经历所以笔试要好好准备。</p>
]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯微信客户端开发一面</title>
    <url>/2022/03/11/%E8%85%BE%E8%AE%AF%E5%BE%AE%E4%BF%A1%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%80%E9%9D%A2/</url>
    <content><![CDATA[<p>已通过</p>
<hr>
<ul>
<li><p>上来先手撕三道代码， 题目不难，都算是经典题，但是给的时间稍微有点儿少，而且一上来就撕代码有点儿懵，导致一道很简单的链表翻转题没做好。。</p>
</li>
<li><p>第一题是链表k个一组翻转</p>
<ul>
<li>一上来有点懵，边界老是处理不好，写了十分钟没写出来就去做后面两道题了，后面两道题比较简单，一会儿就写完了又回来接着做这个。</li>
<li>老是处理不好边界，索性直接把链表存到数组里，在数组里处理，结果最后面试让解释一下代码的时候还是解释的不太清楚。。</li>
</ul>
</li>
<li><p>第二题是把数组的前k个移到最后</p>
<ul>
<li>开了个临时数组存，面试官问不定长数组会有什么问题，如果数组很长那么存在哪里</li>
<li>问有没有更小内存开销的方法，问复杂度（这里答得有点儿混乱）</li>
<li>堆栈的区别</li>
<li>为什么要有堆和栈</li>
</ul>
</li>
<li><p>第三题是最大子数组</p>
</li>
<li><p>问ACM竞赛经历，团队几人，怎么分配工作，过几题能拿牌</p>
</li>
<li><p>问编译器项目，非常详细，一步一步地问</p>
<ul>
<li>词法分析怎么实现的，有没有比字符串匹配更好的方法，答了字典树，又问字典树为什么更好之类的</li>
<li>文法分析，抽象语法树，递归实现，有没有比递归实现更好的方式，答了可以模仿字典树（这里答的不好，面试官说循环递归的问题字典树解决不了，就建不起来这棵树），除了递归和字典树之外还有没有什么方案（不知道。。）</li>
<li>汇编代码生成是干什么的，为什么是四元式，解释了一下操作数操作符操作结果之类的。</li>
<li>寄存器优化怎么实现的，答了引用计数法，问还有哪些地方会用到（内存页面置换），然后问了一些内存页面置换的问题</li>
</ul>
</li>
<li><p>虚拟内存，为什么要有虚拟内存，怎么实现的，页表，页和块</p>
</li>
<li><p>进程间通信有哪些，管道是什么，套接字是什么，共享内存是什么，哪个最快（答了共享内存，不知道对不对）</p>
</li>
<li><p>线程同步方式，信号是什么</p>
</li>
<li><p>为什么要有线程，进程是什么</p>
</li>
<li><p>B+树是什么，有什么特性（答了叶子结点之间有指针），有什么好处（答了查找比较快和擅长范围查找）</p>
</li>
<li><p>TCP和UDP，区别，适用于哪些场景</p>
</li>
<li><p>HTTPS是什么，SSL具体怎么实现，为什么，对称加密和非对称加密的区别</p>
</li>
<li><p>问科研项目</p>
<ul>
<li>持续时间，几个人在做，具体怎么实现，除了超声还有什么方式，wifi可以吗，红外可以吗，摄像头人脸识别怎么样，呼吸和心跳是怎么测得的等等</li>
</ul>
</li>
<li><p>问了开发的app，觉得哪个最好，讲了一下</p>
</li>
<li><p>工作地点是广州，对于工作地点有没有想法</p>
</li>
<li><p>反问环节</p>
<ul>
<li>问了面试官觉得我表现怎么样，有哪些方面可以提高，面试官说原理性的东西可以提高一下，比如做的编译器的原理细节等，思考更深入一点儿</li>
</ul>
</li>
</ul>
<p>总结：问了一个半小时多，是这么多面试里最久的，期间网络很差，换手机热点也很差，断线好几次，后来直接把摄像头关了。面试官问的特别详细，特别深，特别喜欢问为什么。知识点八股文方面答的还行，但是手撕代码和问项目这两个部分出了不少问题，感觉要gg了。。</p>
]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云游戏一面</title>
    <url>/2022/03/10/%E9%98%BF%E9%87%8C%E4%BA%91%E6%B8%B8%E6%88%8F%E4%B8%80%E9%9D%A2/</url>
    <content><![CDATA[<p>接到继续面试的电话了，应该算是过了吧</p>
<hr>
<ul>
<li><p>电话面</p>
</li>
<li><p>自我介绍</p>
</li>
<li><p>问华为的实习经历</p>
<p>做了什么工作，技术难题，工具开源</p>
<p>规则应用于十万行代码的性能？误报率？华为代码安全重复率啥的。。（这些都不了解。。）</p>
</li>
<li><p>问科研项目</p>
<p>系统架构，项目持续时间，从事的工作，硬件组成</p>
</li>
<li><p>团队介绍</p>
<p>原神等的云游戏，可能会跟硬件相关，中心云芯片，高通</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>进程同步和线程同步</title>
    <url>/2022/03/10/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><ol>
<li><p>管道</p>
<p>管道分为命名管道和匿名管道，命名管道可以用于两个或任意多个进程间通信，匿名管道则只能用于有血缘关系（父子进程、兄弟进程、爷孙进程等）的进程间通信。Linux中的“|”命令就是匿名管道，表示把一个进程的输出作为另一个进程的输入。管道就是内核里的一段缓存，从管道一端写入的数据实际上是缓存在内核中，从另一端读取也就是从内核中读取这段数据。管道是半双工的，数据只能向一个方向流动，双方需要互相通信时，需要建立起两个管道。</p>
</li>
<li><p>消息队列</p>
<p>多个不相干的进程可以通过一个消息队列来传递数据，且传递的是一个有意义的数据结构，而管道只能传递没有意义的字节流，还需要在接收端做解析。</p>
</li>
<li><p>共享内存</p>
<p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的一种IPC方式，因为没有内存拷贝的操作，但需要依靠互斥锁或信号量来实现同步。</p>
</li>
<li><p>socket</p>
<p>可用于不同主机之间的进程间通信。</p>
</li>
<li><p>信号</p>
<p>信号是Linux系统中的进程间通信方式，信号可以在任何时候发给某一进程，用于通知该进程某个事件已经发生。比如kill -9命令就可以向指定的进程发送一个终止信号从而杀死进程。</p>
</li>
<li><p>信号量</p>
<p>信号量本质就是一个计数器，记录资源能被多少个进程同时访问，用来实现进程之间的互斥与同步，信号量的引入的是为了解决共享内存通信方式造成的进场安全问题。</p>
</li>
</ol>
<h3 id="进程同步和进程通信"><a href="#进程同步和进程通信" class="headerlink" title="进程同步和进程通信"></a>进程同步和进程通信</h3><ul>
<li><p>进程同步是进程之间按照一定顺序执行，进程通信是进程之间传输信息。</p>
</li>
<li><p>进程通信是一种手段，而进程同步是目的。即为了达到进程同步的目的，需要让进程进行通信，传输一些同步所需要的信息。</p>
</li>
</ul>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ol>
<li><p>互斥锁</p>
<p>互斥锁是线程同步最常用的一种方式，通过互斥锁可以锁定一个代码块，对于被锁定的这个代码块，所有的线程只能串行处理，不能并行处理。</p>
</li>
<li><p>读写锁</p>
<p> 读写锁是互斥锁的升级版，所有线程的读操作都是并行的，只有写操作是串行的。程序中的读操作越多，读写锁性能就越高，相反，若程序中全是写操作，那么读写锁会退化成互斥锁。</p>
</li>
<li><p>条件变量</p>
<p> 条件变量的主要作用不是处理线程同步，而是进行线程的阻塞。常常和互斥锁一起用在生产者和消费者模型中。举个例子：当任务队列为空时，消费者无法消费，使用条件变量把消费者线程阻塞住，等待生产者生产出任务后，再唤醒一个或多个被条件变量阻塞的消费者线程；反过来也可以控制生产者生产的上限，当任务队列达到一个上限值时用条件变量阻塞住生产者线程，直到消费者把任务消费后再唤醒被条件变量阻塞的生产者线程。</p>
</li>
<li><p>信号量</p>
<p>信号量可以实现线程同步也可以实现进程同步，它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。信号量主要阻塞线程，不能完全保证线程安全，如果要保证线程安全，需要和互斥锁一起使用。信号量也可以用来实现生产者消费者模型，在用条件变量实现生产者消费者模型时需要自己做条件判断，而使用信号量就不需要。举个例子：初始化生产者的信号量为5，消费者的信号量为0，因为消费者信号量为0所以会被阻塞，生产者进行一次生产后会将自己的信号量减1，将消费者信号量加1，这时消费者解除阻塞，进行消费后再将自己的信号量减1生产者信号量加1。</p>
</li>
<li><p>自旋锁</p>
<p>自旋锁与互斥锁类似，但它不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。自旋锁可用于一下情况：锁被持有的时间短，而且线程并不希望在重新调度上花费太多成本。</p>
</li>
<li><p>屏障</p>
<p>屏障允许每个线程等待，直到所有的合作线程都到达某一点，然后从该点继续执行。pthread_join函数就是一种屏障，允许一个线程等待，直到另一个线程退出，但屏障允许任意数量的线程等待，直到所有的线程完成处理工作，而线程不需要退出，所有线程达到屏障后可以接着工作。</p>
</li>
</ol>
<h3 id="信号量和互斥锁"><a href="#信号量和互斥锁" class="headerlink" title="信号量和互斥锁"></a>信号量和互斥锁</h3><ul>
<li>互斥锁是由一个线程持有的，加锁和解锁操作在一个线程中执行。而信号量可以由不同线程进行PV操作。</li>
<li>互斥锁用于控制多个线程对于一个共享资源的互斥访问，而信号量用于协调多个线程对于一系列资源的访问。</li>
<li>信号量本质上是一个计数器，其正值代表资源的可用数量，负值代表还有多少个线程在等待资源。</li>
</ul>
<h3 id="条件变量和信号量"><a href="#条件变量和信号量" class="headerlink" title="条件变量和信号量"></a>条件变量和信号量</h3><ul>
<li>信号量利用条件变量、互斥锁、计数器实现，计数器就是信号量的核心，信号量是条件变量的高级抽象。</li>
<li>使用条件变量可以一次唤醒所有等待者，而这个信号量没有的功能，感觉是最大区别。</li>
<li>信号量是有一个值（状态的），而条件变量是没有的，没有地方记录唤醒（发送信号）过多少次，也没有地方记录唤醒线程（wait返回）过多少次。从实现上来说一个信号量可以是用mutex + counter + condition variable实现的。因为信号量有一个状态，如果想精准的同步，那么信号量可能会有特殊的地方。信号量可以解决条件变量中存在的唤醒丢失问题。</li>
</ul>
]]></content>
      <tags>
        <tag>八股文</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>并发一致性</title>
    <url>/2022/03/10/%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7-1/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>问题</th>
<th>原因</th>
<th>封锁级别</th>
<th>解决方法</th>
<th>隔离级别</th>
</tr>
</thead>
<tbody><tr>
<td>丢失修改</td>
<td>一个写操作被另一个写操作覆盖，第一个写操作丢失</td>
<td>一级封锁协议</td>
<td>写操作加X锁，且X锁不共存</td>
<td>未提交读</td>
</tr>
<tr>
<td>读脏数据</td>
<td>读操作读到数据后写操作回滚，则读操作读到脏数据</td>
<td>二级封锁协议</td>
<td>在一级的基础上，读操作加S锁，读完后立刻释放S锁</td>
<td>提交读</td>
</tr>
<tr>
<td>不可重复读</td>
<td>读操作读完数据后，写操作修改数据，读操作再次读取数据发现不一致</td>
<td>三级封锁协议</td>
<td>在二级的基础上，读操作加的S锁不立刻释放，直到事务结束之后再释放</td>
<td>可重复读</td>
</tr>
<tr>
<td>幻读</td>
<td>一般是在操作范围数据时，比如求和或者取平均值，有其它事务在区间内插入或者删除</td>
<td>/</td>
<td>加间隙锁</td>
<td>/</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>八股文</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统的分类</title>
    <url>/2022/03/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2022/03/09/FN65Kiw2grop1fT.png" alt="20220309223559"></p>
<h2 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h2><p>每次从一个IO缓存中，向内存读入一道程序并只有一道程序运行。只有该程序运行结束后才能读入下一道程序。</p>
<p>CPU有大量的时间在空闲等待I/O完成。</p>
<h2 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h2><p>每次读入多道程序，并能并发执行（由操作系统控制，中断的概念），共享计算机资源，CPU和其他资源保持“忙碌”状态。</p>
<p>缺点：美没有人机交互。</p>
<h2 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h2><p>计算机以时间片为单位轮流为各个用户/作业服务（平均主义）。</p>
<p>优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户用时使用一台计算机，并且用户对计算机的操作相互独立。</p>
<p>缺点：不能有限处理一些紧急任务，操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务地紧急性。</p>
<h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><p>在实时操作系统地控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格地时间内容处理完时间。</p>
<p>特点：及时性和可靠性</p>
<p>优点：能优先响应一些紧急任务，无需排队。</p>
<h2 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h2><p>使网络上各计算机能够方便、有效地共享网络资源并为网络用户提供所需的各种服务的软件与协议的集合。</p>
<h2 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h2><p>简单来说就是有一堆计算机，各自物理硬件上是独立的，通过网络相连，互相通信，通过统一的“中间件”进行协调，共享资源，协同分工完成一件任务的计算机集群。</p>
]]></content>
      <tags>
        <tag>知识点</tag>
        <tag>八股文</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>文件描述符</title>
    <url>/2022/03/09/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="描述符表"><a href="#描述符表" class="headerlink" title="描述符表"></a>描述符表</h2><ul>
<li><p>Linux中一切都被抽象成文件，设备也是文件，socket、惯导、消息队列等都是文件。</p>
</li>
<li><p>每个进程都有独立的描述符表。</p>
</li>
<li><p>件描述符就是一个整形变量，表示文件在描述符表中的下标。</p>
</li>
<li><p>每打开一个文件，就会将这个文件的描述符表中。每个进程都有三个默认文件描述符，分别是0（标准输入），1（标准输出），2（标准错误）。</p>
</li>
<li><p>文件描述符一般是调用open()函数返回，调用close()函数会收回对应的文件描述符。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/09/XcuYRK6FqzA4fPk.png" alt="20220309205905"></p>
<h2 id="文件表"><a href="#文件表" class="headerlink" title="文件表"></a>文件表</h2><ul>
<li><p>所有进程共享同一个文件表。</p>
</li>
<li><p>文件表记录了文件的一些信息，比如文件位置、引用计数以及指向v-node表的指针等。</p>
</li>
<li><p>所有打开的文件都有一个文件位置，表示下一次读或写的起始位置。 seek, read, write 函数都可以修改该文件位置。</p>
</li>
<li><p>所有进程共享同一个文件表。文件表中的一个表项可能会被多个描述符指向，引用计数用来表示当前有多少个描述符指向该文件表表项。当调用 close() 函数时，系统会将描述符对应的文件表表项的引用计数减1，然后如果引用计数已经为0，则系统会删除此文件表表项。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/09/lV3DtfpJ5e2HIc7.png" alt="20220309211335"></p>
<h2 id="v-node表"><a href="#v-node表" class="headerlink" title="v-node表"></a>v-node表</h2><ul>
<li><p>所有进程共享同一个 v-node 表。</p>
</li>
<li><p>一个 v-node 表的表项对应于一个文件。它记录了文件的元数据信息。包括文件权限，文件大小，文件类型等信息。</p>
</li>
<li><p>当对同一个文件调用多次 open() 函数，那么会产生多个文件表表项，但是只有一个 v-node 表表项。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/09/PQ2cds8KZJM7eNf.png" alt="20220309211619"></p>
<p><img src="https://s2.loli.net/2022/03/09/I6jGfuCw2BXqHKr.png" alt="20220309212229"></p>
]]></content>
      <tags>
        <tag>知识点</tag>
        <tag>八股文</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O模型</title>
    <url>/2022/03/09/I-O%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="阻塞I-O"><a href="#阻塞I-O" class="headerlink" title="阻塞I/O"></a>阻塞I/O</h2><p>程序发起一次IO操作后就会一直等待，直到IO成功或者失败才能返回，期间不能做其它事情。</p>
<h2 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h2><p>程序发起一次IO后，不断地进行轮询，直到获得数据。</p>
<h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><p>也是阻塞型IO，但是不同的是IO多路复用可以同时阻塞多个IO，并对多个IO进行轮询监控，直到有一个IO的数据可用。</p>
<p>select时间复杂度O(n)，有数量限制；poll时间复杂度O(n)，没有数量限制，因为是用链表实现的；epoll时间复杂度O(1)，是事件驱动的而不是轮询。</p>
<p>epoll使用回调机制而不是轮询，就是当文件描述符就绪后主动通知。</p>
<p>对回调函数调用：调用程序发出对回调函数的调用后，不等函数执行完毕，立即返回并继续执行。这样，调用程序执和被调用函数同时在执行。当被调函数执行完毕后，被调函数会反过来调用某个事先指定函数，以通知调用程序：函数调用结束。这个过程称为回调（Callback），这正是回调函数名称的由来。</p>
<h2 id="信号驱动I-O"><a href="#信号驱动I-O" class="headerlink" title="信号驱动I/O"></a>信号驱动I/O</h2><p>利用系统的信号机制，由内核告诉进程哪一个IO已经完成。</p>
<h2 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h2><p>异步IO是指程序发起IO操作之后就去干其它事情，而不需要等待IO结果。</p>
<p>跟信号驱动IO优点像，但区别是信号驱动IO在内核提醒IO完成之后还要程序完成数据从内核态到用户态的拷贝，而异步IO是在数据拷贝完成之后才通知的程序。</p>
]]></content>
      <tags>
        <tag>知识点</tag>
        <tag>八股文</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>函数指针</title>
    <url>/2022/03/09/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针就是指向函数的指针。</p>
<h2 id="函数指针的作用"><a href="#函数指针的作用" class="headerlink" title="函数指针的作用"></a>函数指针的作用</h2><ol>
<li><p>实现多态</p>
<ul>
<li><p>比如c++面向对象编程里的虚函数。</p>
</li>
<li><p>以及面向过程编程的多态指的是，具体执行哪个函数不是在编译时决定的，而是在函数运行时根据函数指针的值来决定的。</p>
</li>
</ul>
</li>
<li><p>回调函数</p>
<p>函数指针作为某个函数的参数，通过函数参数调用的函数就是回调函数。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>知识点</tag>
        <tag>八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>语言</title>
    <url>/2022/03/08/%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h2 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a>动态类型语言和静态类型语言</h2><ul>
<li>动态类型语言：在程序运行时才检查数据类型。即在编程时不要要指定变量的类型，运行时会根据变量的赋值自动确定类型。比如JacvaScript,Python。</li>
<li>静态类型语言：在编译时检查数据类型。在编写程序时就需要指定变量的类型。比如C/C++,Java。</li>
</ul>
<h2 id="编译型语言和解释型语言"><a href="#编译型语言和解释型语言" class="headerlink" title="编译型语言和解释型语言"></a>编译型语言和解释型语言</h2><ul>
<li>编译型语言：在运行前需要经过一个单独的编译，将程序翻译成机器语言，然后在机器上执行。优点是块，因为执行机器语言时不用再编译，缺点是平台关联性强。比如C/C++。</li>
<li>解释型语言：解释型语言不需要编译，可以直接运行，运行时由解释器负责解释。比如Python。</li>
<li>混合型语言：Java即是编译型的，也是解释型语言，总的来说Java更接近解释型语言。<ul>
<li>可以说它是编译型的。因为所有的Java代码都是要编译的，.java不经过编译就什么用都没有。</li>
<li>可以说它是解释型的。因为Java代码编译后不能直接运行，它是解释运行在JVM上的，所以它是解释运行的。</li>
</ul>
</li>
</ul>
<h2 id="脚本语言"><a href="#脚本语言" class="headerlink" title="脚本语言"></a>脚本语言</h2><ul>
<li>源程序是文本格式，可以被解释执行的语言可以算作脚本语言。</li>
<li>解释语言是说解释执行的语言，但执行的代码并不一定是文本格式的。脚本语言的程序是文本文件，并且是解释执行的。</li>
</ul>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>科研项目</title>
    <url>/2022/03/07/%E7%A7%91%E7%A0%94%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="基于超声波的驾驶员头部朝向追踪和生命体征监控系统"><a href="#基于超声波的驾驶员头部朝向追踪和生命体征监控系统" class="headerlink" title="基于超声波的驾驶员头部朝向追踪和生命体征监控系统"></a>基于超声波的驾驶员头部朝向追踪和生命体征监控系统</h2><h2 id="项目内容"><a href="#项目内容" class="headerlink" title="项目内容"></a>项目内容</h2><ul>
<li><p>头部朝向追踪</p>
<ul>
<li><p>方案：基于超声波测距和定位算法。</p>
</li>
<li><p>应用：估计驾驶员的意图用于智能驾驶。</p>
</li>
</ul>
</li>
<li><p>生命体征监控</p>
<ul>
<li><p>方案：对2*8通道的超声信号一起进行主成分分析，从中提取驾驶员的呼吸和心跳信息。</p>
</li>
<li><p>应用：检测驾驶员疲劳驾驶和危险动作识别。</p>
</li>
</ul>
</li>
</ul>
<h2 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h2><ul>
<li><p>声波信号的多径问题</p>
<ul>
<li><p>原因：由于环境中物体的反射，无线信号普遍存在的多径问题，即从发射端到达接收端会有多个不同的路径，包括直达径和多个反射径。</p>
</li>
<li><p>解决方案：采用Zadoff-Chu序列来调制超声信号，zc信号具有很好的多径分辨能力。</p>
</li>
</ul>
</li>
<li><p>直达径被遮挡问题</p>
<ul>
<li><p>原因：超声波测距和定位算法基于直达径信号传播时间的估计，如果直达径被遮挡，那么测得的就是反射径的距离，无法用于定位。</p>
</li>
<li><p>解决方案：理论上只需要三个接收端就可以根据三点定位算法完成发射端定位，通过布置更多的接收端保证头部不管怎样旋转都至少与三个接收端之间的直达径不被遮挡。</p>
</li>
</ul>
</li>
<li><p>只能定位头部的两个坐标</p>
<ul>
<li><p>原因：理论上至少需要知道物体上三个点的坐标才能确定其在三维空间中的朝向，但是生活中大多数设备都只支持双声道，而且实验用的数据采集卡也只支持两发，所以只能完成两个点的定位。</p>
</li>
<li><p>解决方案：提出“轴点”的假设，因为驾驶员在驾驶过程中头部动作十分有限，而且不会有复杂的动作，所以可以根据两个发射端的轨迹估计出驾驶员的动作，进而推算出轴点的位置。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>编译器项目</title>
    <url>/2022/03/07/%E7%BC%96%E8%AF%91%E5%99%A8%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="基于C0文法的编译器设计与开发"><a href="#基于C0文法的编译器设计与开发" class="headerlink" title="基于C0文法的编译器设计与开发"></a>基于C0文法的编译器设计与开发</h2><h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><p>大三时编译原理课程，报名参加了试点班。试点班就是不用参加平常的理论课和实验课，只需要用一学期的时间开发出一个编译器。但是一共三四十名学生报名参加了试点班，最后我的成绩是最高的。</p>
<p>在上编译原理这门课之前对编译器可以说是一无所知，所以一开始上手很困难。老师给了我们一本编译原理的书，就是号称编译原理三大圣经之一的龙书，然后给了我们一个编译原理的网课让我们自学。看了一段时间书和网课然后慢慢开始一点点上手实践。</p>
<h3 id="项目流程"><a href="#项目流程" class="headerlink" title="项目流程"></a>项目流程</h3><p>编译器开发主要分为四大块：词法分析、语法分析、中间代码生成和汇编代码生成。</p>
<ul>
<li>词法分析主要是将源代码的字符串划分为token，每个token都包含了一个划分出来的词以及这个词的类型。</li>
<li>语法分析就是按照定义好的语法规则将词法分析生成的tokens转换成抽象语法树的过程。</li>
<li>中间代码生成式在语法分析的过程中，将语法树转换成四元组的形式，使用四元组主要是为了方便后续汇编代码生成。</li>
<li>汇编代码生成就是将四元组转化成对应的汇编代码，比如我采用的mips指令集。</li>
</ul>
<h3 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h3><ul>
<li><p>寄存器优化</p>
<p>  不进行优化的方案就是，每次对变量进行操作的时候，都需要先将变量从内存读到寄存器，然后在寄存器上对变量进行操作，操作完成后再将变量写回寄存器，所以每次使用一个变量都会带来两次寄存器读写，这是很耗时间的，尤其是当对一个变量进行反复修改，就得不断的反复从内存读出写入。</p>
<p>  所以最好的解决方案是，给每个变量都分配一个寄存器，等到程序结束的时候再一起写回。但是实际中寄存器的数量是很有限的，以mips指令集为例，一般只有32位寄存器，除去一些有特殊用处的能够使用的寄存器可能只有十几二十几个，而一段代码内部的变量可能有很多，所以没办法给每个变量都分配一个寄存器。</p>
<p>  可以尽可能多的把寄存器分配给变量，但是当寄存器用完了而又来了新变量时，就必须做出一个抉择就是要把哪个旧的变量踢出寄存器。这个选择做的好坏非常影响编译器的性能。</p>
<p>  当时对这方面的算法了解不多，所以采取了一个比较简单的算法，就是引用计数法。即每次使用一个变量都对将它的计数器加一，然后需要踢出变量的时候就优先踢出计数器次数最小的那个。这种方法再大多数情况下是有效的，但是有些极端情况比如寄存器震荡等。</p>
<p>  后来慢慢接触到其它知识后，了解到这个问题其实跟很多其它问题类似，比如内存的页面置换等。有一些很好的算法，比如LRU等，这也是这个编译器后续可以继续优化的方向。</p>
</li>
<li><p>函数调用时的压栈和出栈设计</p>
<p>每个函数都在内存中对应着一段栈帧，栈帧由栈顶和栈底两个寄存器确定，mips里叫做sp和fp。</p>
<p>调用函数时，先将函数参数压栈压栈，再将返回地址压栈，再将栈底位置压栈，然后将栈底指向栈顶也就是当前位置，之后就是新函数的栈帧。</p>
<p>函数调用结束后，出栈的顺序跟入栈的顺序相反，先让栈顶指向栈底，意味着将该函数的栈帧取消，再将栈底移到它指向的值，即回到上一个栈底的位置，从而恢复上一个函数的栈帧，然后再将放回地址出栈，让指令寄存器回到返回地址处继续执行程序。</p>
</li>
<li><p>多重for循坏的线性化</p>
<p>通过mips的label和jump指令将for循环展开</p>
</li>
</ul>
<h3 id="后续的优化方向"><a href="#后续的优化方向" class="headerlink" title="后续的优化方向"></a>后续的优化方向</h3><ul>
<li>增加一些功能，比如多维数组、结构体等。</li>
<li>改进寄存器优化算法，比如增加计数器衰减或者使用LRU算法等。</li>
</ul>
]]></content>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>系统调用</title>
    <url>/2022/03/04/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用就是调用操作系统提供的一系列内核功能函数，因为内核总是对用户程序持不信任的态度，一些核心功能不能直接交由用户程序来实现执行。用户程序只能发出请求，然后内核调用相应的内核函数来帮着处理，将结果返回给应用程序。如此才能保证系统的稳定和安全。</p>
<p>系统调用是给用户态下的程序使用的，但是用户程序并不直接使用系统调用，而是系统调用在用户态下的接口。这个用户接口就是操作系统提供的系统调用API，一般遵循POSIX标准。</p>
<p>每一个系统调用都唯一分配了一个整数来标识，通常的做法就是将这个系统调用号放进eax寄存器，当执行到系统调用入口程序的时候就会根据eax的值去调用具体的系统调用程序，比如说eax中存放的是1那么就会去调用fork这个系统调用的相关函数。</p>
<h3 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h3><ul>
<li><p>参数</p>
<p>  有些系统调用的是需要参数的，用户接口不真正干活，真正干活的是内核功能函数，但是需要的参数在用户态下，所以需要在用户接口部分向内核传递参数。传参有两种方法：</p>
<ul>
<li><p>直接传给寄存器，寄存器是通用的，在用户态将值传给寄存器，进入内核态之后就可以直接使用，这可以使用内联汇编来实现。</p>
</li>
<li><p>压栈，压栈有个问题，系统调用使用中断/陷阱来实现，这期间会换栈，在用户态下压栈的参数对内核来说似乎没什么用处。所以要想使用用户态下栈中的参数，必须要获得用户栈的地址，这个值在哪呢？没错，在内核栈中的上下文保存着，从内核栈中取出用户栈的栈顶esp值，就可以取到系统调用的参数了，xv6就是这样实现的。</p>
</li>
</ul>
</li>
<li><p>返回值</p>
<p>  函数的调用约定中规定了返回值应该放在eax寄存器里面。而在系统调用的一开始我们将系统调用号传进了eax寄存器，然后中断时保存上下文，将eax压入内核栈，系统调用处理程序将最后结果放到eax寄存器中。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>语法糖</title>
    <url>/2022/03/04/%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
    <content><![CDATA[<p>语法糖(syntactic sugar)，也译为糖衣语法，是由英国计算机科学家彼得·约翰·兰达（Peter J. Landin）发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</p>
<p>语法糖是指编程语言中可以更容易的表达一个操作的语法，它可以使程序员更加容易去使用这门语言：操作可以变得更加清晰、方便，或者更加符合程序员的编程习惯。</p>
<p>具体来说，语法糖是指语言中的一个构件，当去掉该构件后并不影响语言的功能和表达能力。</p>
<p>例如，C语言中的标记a[i]就是*(a+i)的语法糖。</p>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>STL</title>
    <url>/2022/03/03/STL/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>STL</th>
<th>类型</th>
<th>名称</th>
<th>底层实现</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>vector</td>
<td>顺序型容器</td>
<td>变长数组</td>
<td>数组</td>
<td>O(1)查找O(n)插入</td>
</tr>
<tr>
<td>list</td>
<td>顺序型容器</td>
<td>链表</td>
<td>双向链表</td>
<td>O(n)查找O(1)插入</td>
</tr>
<tr>
<td>deque</td>
<td>顺序型容器</td>
<td>双端队列</td>
<td>类似二维数组</td>
<td>由若干段大小相等的连续内存组成，不同段之间可能不连续，数组中每个节点都指向一段内存</td>
</tr>
<tr>
<td>map</td>
<td>有序关联型容器</td>
<td>映射</td>
<td>红黑树</td>
<td>按照key值排序，key不重复</td>
</tr>
<tr>
<td>mutimap</td>
<td>有序关联型容器</td>
<td>多重映射</td>
<td>红黑树</td>
<td>按照key值排序，key可重复</td>
</tr>
<tr>
<td>set</td>
<td>有序关联型容器</td>
<td>集合</td>
<td>红黑树</td>
<td>按照key值排序，key不重复</td>
</tr>
<tr>
<td>mutiset</td>
<td>有序关联型容器</td>
<td>多重集合</td>
<td>红黑树</td>
<td>按照key值排序，key可重复</td>
</tr>
<tr>
<td>unordered_map</td>
<td>无序关联型容器</td>
<td>无序映射</td>
<td>哈希表</td>
<td>不排序，用链表法解决哈希冲突（哈希桶）</td>
</tr>
<tr>
<td>stack</td>
<td>容器适配器</td>
<td>栈</td>
<td>deque</td>
<td>先进后出</td>
</tr>
<tr>
<td>queue</td>
<td>容器适配器</td>
<td>队列</td>
<td>deque</td>
<td>先进先出</td>
</tr>
</tbody></table>
<ul>
<li><p>容器支持迭代器，容器适配器不支持迭代器。</p>
</li>
<li><p>map中的基本元素就是对组pair。</p>
</li>
<li><p>pair是用一个结构体实现的，结构体主要的两个成员变量first和second，分别存储两个数据。</p>
</li>
<li><p>map中的pair第一个元素为key(键值)，起索引作用，就相当于数组下标，第二个元素为value(实值)。map所有元素会根据键值大小自动排序</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>买卖股票问题总结</title>
    <url>/2022/03/02/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>leetcode上买卖股票问题一共有六道题，六道题十分相似，只要掌握一个算法稍作修改就可以都AC掉，现做一个总结。</p>
<h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><p>只能买卖一次</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> buy = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> sell = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        buy = <span class="built_in">max</span>(buy, <span class="number">0</span>-prices[i]);</span><br><span class="line">        sell = <span class="built_in">max</span>(sell, prices[i]+buy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h2><p>可以买卖多次</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> buy = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> sell = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        buy = <span class="built_in">max</span>(buy, sell-prices[i]);</span><br><span class="line">        sell = <span class="built_in">max</span>(sell, prices[i]+buy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票的最佳时机-III"><a href="#买卖股票的最佳时机-III" class="headerlink" title="买卖股票的最佳时机 III"></a>买卖股票的最佳时机 III</h2><p>只能买卖两次</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> buy = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> sell = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> buy2 = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> sell2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        buy = <span class="built_in">max</span>(buy, <span class="number">0</span>-prices[i]);</span><br><span class="line">        sell = <span class="built_in">max</span>(sell, prices[i]+buy);</span><br><span class="line">        buy2 = <span class="built_in">max</span>(buy2, sell-prices[i]);</span><br><span class="line">        sell2 = <span class="built_in">max</span>(sell2, prices[i]+buy2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sell2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票的最佳时机-IV"><a href="#买卖股票的最佳时机-IV" class="headerlink" title="买卖股票的最佳时机 IV"></a>买卖股票的最佳时机 IV</h2><p>只能买卖K次</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> buy[k+<span class="number">1</span>], sell[k+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        buy[i] = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">        sell[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">            buy[j] = <span class="built_in">max</span>(buy[j], sell[j<span class="number">-1</span>]-prices[i]);</span><br><span class="line">            sell[j] = <span class="built_in">max</span>(sell[j], prices[i]+buy[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sell[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a>最佳买卖股票时机含冷冻期</h2><p>有一天冷冻期，卖了之后隔一个天才能再买</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> buy = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> sell = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sell2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        buy = <span class="built_in">max</span>(buy, sell2-prices[i]);</span><br><span class="line"></span><br><span class="line">        sell2 = sell;</span><br><span class="line">        sell = <span class="built_in">max</span>(sell, prices[i]+buy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a>买卖股票的最佳时机含手续费</h2><p>每次买卖需要交手续费fee（同一次买卖只交一次）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> buy = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> sell = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        buy = <span class="built_in">max</span>(buy, sell-prices[i]-fee);</span><br><span class="line">        sell = <span class="built_in">max</span>(sell, prices[i]+buy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>刷题</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>页表和快表</title>
    <url>/2022/03/02/%E9%A1%B5%E8%A1%A8%E5%92%8C%E5%BF%AB%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><ul>
<li><p>页表是将逻辑地址转换为物理地址。</p>
</li>
<li><p>页表内存储的是页号和块号的映射。</p>
</li>
<li><p>逻辑地址整除页长得到的商就是页号，余数就是页面偏移量。</p>
</li>
<li><p>通过页表将页号转换为块号，在用块号和页面偏移量即可得到数据在内存中的物理地址。</p>
</li>
<li><p>当请求的页面不在内存中时（页表中还有状态位等信息表示页面是否在内存中），发生缺页中断将需要的页面调入内存，如果内存没有多余的空间则使用页面置换算法替换掉内存中的某个页。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/02/3oqNDV2jnAOx5EL.png" alt="20220302085955"></p>
<h2 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h2><ul>
<li><p>快表是一种比内存快很多的高速缓存存储器</p>
</li>
<li><p>快表存储的是一些常用的的页号，相当于页表的cache，如果快表命中了则不需要再访问页表。</p>
</li>
<li><p>快表中的页一定在内存中，页表中的页不一定在内存中。</p>
</li>
<li><p>快表命中了只需要访问一次内存，没命中则需要访问两次内存（访问页表一次加访问数据一次）。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/02/9LqQ8Ycj6S7oEhF.png" alt="20220302091110"></p>
]]></content>
      <tags>
        <tag>八股文</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>线程锁POSIX</title>
    <url>/2022/03/01/%E7%BA%BF%E7%A8%8B%E9%94%81POSIX/</url>
    <content><![CDATA[<ul>
<li><p>互斥锁（mutex，互斥量）</p>
<p>互斥锁是用于控制多个线程对他们之间共享资源互斥访问的一个信号量。</p>
<p>互斥锁属于sleep-waiting类型的锁。例如在一个双核的机器上有两个线程A和B，它们分别运行在core 0和core 1上。假设线程A想要通过pthread_mutex_lock操作去得到一个临界区的锁，而此时这个锁正被线程B所持有，那么线程A就会被阻塞，此时会通过上下文切换将线程A置于等待队列中，此时core 0就可以运行其他的任务（如线程C）。</p>
</li>
<li><p>条件锁（cond，条件变量）</p>
<p>条件锁就是所谓的条件变量，某一个线程因为某个条件为满足时可以使用条件变量使改程序处于阻塞状态。一旦条件满足以“信号量”的方式唤醒一个因为该条件而被阻塞的线程。最为常见就是在线程池中，起初没有任务时任务队列为空，此时线程池中的线程因为“任务队列为空”这个条件处于阻塞状态。一旦有任务进来，就会以信号量的方式唤醒一个线程来处理这个任务，这个过程中就使用到了条件变量。</p>
<p>互斥锁实现的是线程的互斥，条件锁实现的是线程的同步。</p>
</li>
<li><p>自旋锁（spin）</p>
<p>自旋锁属于busy-waiting类型的锁，当线程A请求自旋锁，如果自旋锁已经被线程B所持有，那么线程A就会一直在core 0上进行忙等待并不停的进行锁请求，检查该自旋锁是否已经被线程B释放，直到得到这个锁为止。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。</p>
</li>
<li><p>读写锁</p>
<p>可以有多个读线程同时获取读的锁，而只有一个线程可以获取写的锁。读锁和写锁互斥，写锁和写锁互斥。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>八股文</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信的七种方式</title>
    <url>/2022/03/01/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E4%B8%83%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="进程间通信的7种方式"><a href="#进程间通信的7种方式" class="headerlink" title="进程间通信的7种方式"></a>进程间通信的7种方式</h2><ol>
<li><p>管道（Pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用，允许一个进程和另一个与它有共同祖先的进程之间进行通信。</p>
</li>
<li><p>命名管道（named pipe）：也是半双工的通信方式，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。</p>
</li>
<li><p>信号（Signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。比如Ctrl+C就是一种程序终止(interrupt)信号。</p>
</li>
<li><p>消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺</p>
</li>
<li><p>共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</p>
</li>
<li><p>信号量（semaphore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
</li>
<li><p>套接字（Socket）：与其他通信机制不同的是，它可用于不同机器间的进程通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>知识点</tag>
        <tag>八股文</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>const的作用</title>
    <url>/2022/02/28/const%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h2 id="const的作用"><a href="#const的作用" class="headerlink" title="const的作用"></a>const的作用</h2><ol>
<li><p>阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；</p>
</li>
<li><p>对指针来说，可以指定指针本身为const（指针常量：int* const p），也可以指定指针所指的数据为const（常量指针：const int* p），或二者同时指定为const（常指针常量：const int* const p）；</p>
</li>
<li><p>类的常函数可以访问const和非const的成员变量，但不能修改类的成员变量；</p>
<p>this指针默认是指针常量，所以不能修改this指针的指向。在成员函数后面加const变成常函数，实际是修饰的是this指针，将this指针变成常指针常量，使其不能修改指向的值。</p>
</li>
<li><p>常对象只能调用常函数，非常对象可以调用常函数也可以调用非常函数；</p>
</li>
<li><p>const类型变量必须定义的时候进行初始化，因此也导致如果类的成员变量有const类型的变量，那么该变量必须在类的初始化列表中进行初始化；</p>
</li>
<li><p>const类型变量可以通过类型转换符const_cast将const类型转换为非const类型；</p>
</li>
<li><p>在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；</p>
</li>
<li><p>对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只能改变临时变量，但无法改变实参。则这个时候无论加不加const对实参不会产生任何影响。但是在引用或指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。因为在编译阶段编译器对调用函数的选择是根据实参进行的，所以，只有引用传递和指针传递可以用是否加const来重载。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>static的作用和用法</title>
    <url>/2022/02/28/static%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="static的用法和作用"><a href="#static的用法和作用" class="headerlink" title="static的用法和作用"></a>static的用法和作用</h2><ol>
<li><p>隐藏</p>
<p>当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。</p>
<p>加static的全局变量只有本文件内能访问。</p>
</li>
<li><p>保持变量内容的持久</p>
<p> （static变量中的记忆功能和全局生存期）</p>
<p> 存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。</p>
</li>
<li><p>默认初始化为0</p>
<p> 其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。</p>
</li>
<li><p>类成员声明为static</p>
<ul>
<li>函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值</li>
<li>在模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其它函数访问；</li>
<li>在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；</li>
<li>在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；</li>
<li>在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。</li>
<li>static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化；</li>
<li>由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员；</li>
<li>static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this-&gt;vptr-&gt;ctable-&gt;virtual function</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>宏定义和typedef</title>
    <url>/2022/02/27/%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8Ctypedef/</url>
    <content><![CDATA[<h2 id="宏定义和typedef区别"><a href="#宏定义和typedef区别" class="headerlink" title="宏定义和typedef区别"></a>宏定义和typedef区别</h2><ul>
<li><p>宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。</p>
</li>
<li><p>宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。</p>
</li>
<li><p>宏不检查类型；typedef会检查数据类型。</p>
</li>
<li><p>宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。</p>
</li>
<li><p>注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。</p>
<p>一个经典例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT int*</span></span><br><span class="line">INT a,b;</span><br></pre></td></tr></table></figure>

<p>这里a的类型是int*，而b的类型是int。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> * INT  </span><br><span class="line">INT a,b;</span><br></pre></td></tr></table></figure>

<p>这里的a,b都是int *类型。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>指针数组与数组指针</title>
    <url>/2022/02/27/%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E4%B8%8E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p[<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">p</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">int</span> <span class="params">(*p)</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。</p>
</li>
<li><p>int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。</p>
</li>
<li><p>int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。</p>
</li>
<li><p>int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>GET和POST</title>
    <url>/2022/02/26/GET%E5%92%8CPOST/</url>
    <content><![CDATA[<ol>
<li><p>报文上的区别</p>
<p> GET 和 POST 只是 HTTP 协议中两种请求方式，所以在传输上，没有区别，因为HTTP 协议是基于 TCP/IP 的应用层协议<br> 报文格式上，不带参数时，最大区别仅仅是第一行方法名不同，一个是GET，一个是POST。</p>
<p> 带参数时报文的区别呢？在约定中，GET方法的参数应该放在url中，POST方法参数应该放在body中。</p>
<p> 举个例子，如果参数是 name=qiming.c, age=22。</p>
<p> GET 方法简约版报文可能是这样的：</p>
<pre><code> GET /index.php?name=qiming.c&amp;age=22 HTTP/1.1
 Host: localhost
</code></pre>
<p> POST 方法简约版报文可能是这样的：</p>
<pre><code> POST /index.php HTTP/1.1
 Host: localhost
 Content-Type: application/x-www-form-urlencoded name=qiming. c&amp;age=22
</code></pre>
</li>
<li><p>传输数据的大小</p>
<p> 在HTTP规范中，没有对URL的长度和传输的数据大小进行限制。但是在实际开发过程中，对于GET，特定的浏览器和服务器对URL的长度有限制。因此，在使用GET请求时，传输数据会受到URL长度的限制。</p>
<p> 对于POST，由于不是URL传值，理论上是不会受限制的，但是实际上各个服务器会规定对POST提交数据大小进行限制，Apache、IIS都有各自的配置。</p>
</li>
<li><p>安全性</p>
<p> POST的安全性比GET的高。比如，在进行登录操作，通过GET请求，用户名和密码都会暴露再URL上，因为登录页面有可能被浏览器缓存以及其他人查看浏览器的历史记录的原因，此时的用户名和密码就很容易被他人拿到了。除此之外，GET请求提交的数据还可能会造成Cross-site request frogery攻击。</p>
</li>
</ol>
<p>深入理解</p>
<ol>
<li><p>GET和POST都是http请求方式，底层都是TCP/IP协议；通常GET 产生一个TCP数据包；POST产生两个TCP数据包（但firefox是发送一个数据包），</p>
</li>
<li><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）表示成功；</p>
<p> 而对于POST，浏览器先发送header，服务器响应100， 浏览器再继续发送data，服务器响应200 （返回数据）。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>FTP的主动模式和被动模式</title>
    <url>/2022/02/26/FTP%E7%9A%84%E4%B8%BB%E5%8A%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A2%AB%E5%8A%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="FTP主动模式"><a href="#FTP主动模式" class="headerlink" title="FTP主动模式"></a>FTP主动模式</h3><p><img src="https://s2.loli.net/2022/02/26/GS76hwuCjb9i3QF.png" alt="20220226094738"></p>
<ol>
<li><p>在主动模式下，客户端命令端口为N，数据端口为N+1，服务器端命令端口为21，数据端口为20。</p>
<p> 第一步，客户端使用端口N连接FTP服务器的命令端口21，建立控制连接并告诉服务器我这边开启了数据端口N+1。</p>
<p> 第二步，在控制连接建立成功后，服务器会使用数据端口20，主动连接客户端的N+1端口以建立数据连接。这就是FTP主动模式的连接过程。</p>
<p> 我们可以看到，在这条红色的数据连接建立的过程中，服务器是主动的连接客户端的，所以称这种模式为主动模式。</p>
</li>
<li><p>主动模式的利弊</p>
<p> 主动模式对FTP服务器的管理有利，因为FTP服务器只需要开启21端口的“准入”和20端口的“准出”即可。</p>
<p> 但这种模式对客户端的管理不利，因为FTP服务器20端口连接客户端的数据端口时，有可能被客户端的防火墙拦截掉。</p>
</li>
</ol>
<h3 id="FTP被动模式"><a href="#FTP被动模式" class="headerlink" title="FTP被动模式"></a>FTP被动模式</h3><p><img src="https://s2.loli.net/2022/02/26/CrznktXQZPiyAqg.png" alt="20220226094949"></p>
<ol>
<li><p>在被动模式下，客户端命令端口为N，数据端口为N+1，服务器端命令端口为21，数据端口为P。</p>
<p> 第一步，客户端的命令端口N主动连接服务器命令端口21，并发送PASV命令，告诉服务器用“被动模式”，控制连接建立成功后，服务器开启一个数据端口P，通过PORT命令将P端口告诉客户端。</p>
<p> 第二步，客户端的数据端口N+1去连接服务器的数据端口P，建立数据连接。</p>
<p> 我们可以看到，在这条红色的数据连接建立的过程中，服务器是被动的等待客户端来连接的，所以称这种模式为被动模式。</p>
</li>
<li><p>被动模式利弊</p>
<p> 被动模式对FTP客户端的管理有利，因为客户端的命令端口和数据端口都是“准出”，windows防火墙对于“准出”一般是不拦截的，所以客户端不需要任何多余的配置就可以连接FTP服务器了。</p>
<p> 但对服务器端的管理不利。因为客户端数据端口连到FTP服务器的数据端口P时，很有可能被服务器端的防火墙阻塞掉。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP状态码</title>
    <url>/2022/02/26/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<p>http状态码的由三位数字和原因短语组成，数字的第一位数字表示响应的类别，后面两位无类别。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>临时状态码，表示正在处理请求</td>
</tr>
<tr>
<td>2XX</td>
<td>请求处理成功</td>
</tr>
<tr>
<td>3XX</td>
<td>重定向，表示要完成请求需要进一步操作</td>
</tr>
<tr>
<td>4XX</td>
<td>请求错误，错误的原因在客户端，比如请求的参数错误或者url过长等</td>
</tr>
<tr>
<td>5XX</td>
<td>服务器错误，比如服务不可用或者服务器内部出错</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>我的日程安排表</title>
    <url>/2022/02/24/%E6%88%91%E7%9A%84%E6%97%A5%E7%A8%8B%E5%AE%89%E6%8E%92%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>当 k 个日程安排有一些时间上的交叉时（例如 k 个日程安排都在同一时间内），就会产生 k 次预订。</p>
<p>给你一些日程安排 [start, end) ，请你在每个日程安排添加后，返回一个整数 k ，表示所有先前日程安排会产生的最大 k 次预订。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>插旗法：进入一个区间的时候将该点坐标对应的值+1，代表插上一面进入的🚩，离开时将该点坐标值-1，代表插上一面离开的🚩，在同一个点可以同时插进入的旗或离开的旗，因为这样并不形成区间重叠。</p>
<p>通过计数器cnt可以得到当前重叠次数，如果不能重叠则cnt&gt;1就返回false（如我的日程安排表一），如果不能重叠三次就cnt&gt;2再返回false（如我的日程安排表二），如果要求最大重叠次数就返回cnt最大值（如我的日程安排表三）。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; rec;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    rec[start] ++;</span><br><span class="line">    rec[end] --;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;a: rec)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if(cnt&gt;1)&#123;</span></span><br><span class="line"><span class="comment">            rec[start] --;</span></span><br><span class="line"><span class="comment">            rec[end] ++;</span></span><br><span class="line"><span class="comment">            return false;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        cnt += a.second;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>十大排序算法</title>
    <url>/2022/02/24/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2022/02/24/GDViCKSkOUqLPtY.png" alt="20220224105819"></p>
<p><img src="https://s2.loli.net/2022/02/24/njH3MlzIhiC7Nec.png" alt="20220224105839"></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>桶排序、计数排序和基数排序</title>
    <url>/2022/02/24/%E6%A1%B6%E6%8E%92%E5%BA%8F%E3%80%81%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E5%92%8C%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序是一种用空间换取时间的排序，桶排序重要的是它的思想，而不是具体实现，时间复杂度最好可能是线性O(n)，桶排序不是基于比较的排序而是一种分配式的。</p>
<p>桶排序的思想为：将待排序的序列分到若干个桶中，每个桶内的元素再进行个别排序。 当然桶排序选择的方案跟具体的数据有关系，桶排序是一个比较广泛的概念，并且计数排序是一种特殊的桶排序，基数排序也是建立在桶排序的基础上。在数据分布均匀且每个桶元素趋近一个时间复杂度能达到O(n),但是如果数据范围较大且相对集中就不太适合使用桶排序。</p>
<p><img src="https://s2.loli.net/2022/02/24/VNs3kwxiMaE7KZT.png" alt="20220224104715"></p>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序是一种特殊的桶排序，每个桶的大小为1，每个桶不在用List表示，而通常用一个值用来计数。</p>
<p>在设计具体算法的时候，先找到最小值min，再找最大值max。然后创建这个区间大小的数组，从min的位置开始计数，这样就可以最大程度的压缩空间，提高空间的使用效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> min=Integer.MAX_VALUE;<span class="keyword">int</span> max=Integer.MIN_VALUE;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)<span class="comment">//找到max和min</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]&lt;min) </span><br><span class="line">      min=a[i];</span><br><span class="line">    <span class="keyword">if</span>(a[i]&gt;max)</span><br><span class="line">      max=a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> count[]=<span class="keyword">new</span> <span class="keyword">int</span>[max-min+<span class="number">1</span>];<span class="comment">//对元素进行计数</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    count[a[i]-min]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//排序取值</span></span><br><span class="line">  <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count.length;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> (count[i]--&gt;<span class="number">0</span>) &#123;</span><br><span class="line">      a[index++]=i+min;<span class="comment">//有min才是真正值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序也称为卡片排序，基数排序的原理就是多次利用计数排序(计数排序是一种特殊的桶排序)，但是和前面的普通桶排序和计数排序有所区别的是，基数排序并不是将一个整体分配到一个桶中，而是将自身拆分成一个个组成的元素，每个元素分别顺序分配放入桶中、顺序收集，当从前往后或者从后往前每个位置都进行过这样顺序的分配、收集后，就获得了一个有序的数列。</p>
<h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p>基数排序就是进行d论计数排序，d是最大数字的长度。每一轮排序就是针对每个数字的某一位做计数排序，每一轮排序的结果是所有元素不一定有序，但是在这一位上是有序。然后在对下一位进行下一轮的计数排序，所有数字在该位上是有序的，该位相等的那些数字在上一位是有序的。所以一共进行d论计数排序之后，所有数字都是有序的。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><a href="https://jepson-song.github.io/2021/12/01/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/">https://jepson-song.github.io/2021/12/01/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</a></p>
]]></content>
      <tags>
        <tag>刷题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/2022/02/24/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="排序原理"><a href="#排序原理" class="headerlink" title="排序原理"></a>排序原理</h2><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<p>简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。</p>
<p>而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。</p>
<p>好像有人证明希尔排序的时间复杂度是O(n^1.3)</p>
<p><img src="https://s2.loli.net/2022/02/24/gjkAKLSPoGYuCRV.png" alt="20220224103652"></p>
<p>动图：</p>
<p><img src="https://s2.loli.net/2022/02/24/ZWMs3SkyAr1mu4I.png" alt="20220224103635"></p>
<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>希尔排序的核心就是通过步长比较大的那几次插入排序保证了数组是基本有序的，然后再进行步长小的插入排序时不需要进行过多的比较和交换。</p>
<p>在进行每一轮插入排序时，遇到第一个非逆序时就直接break就行了，我认为这才是希尔排序比简单插入排序快的原因。而网上大量博客都没说清楚，甚至代码里都没有这个break，这样性能可能还没有普通插入排序高。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> d=n/<span class="number">2</span>;d&gt;=<span class="number">1</span>;d/=<span class="number">2</span>)&#123; <span class="comment">// 步长d，共分为d组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=d;i&lt;n;i++)&#123;  <span class="comment">// 对每个元素进行组内插入排序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=d;j-=d)&#123; <span class="comment">// 组内插入排序</span></span><br><span class="line">                <span class="keyword">if</span>(nums[j-d]&gt;nums[j]) <span class="built_in">swap</span>(nums[j-d], nums[j]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>; <span class="comment">// 希尔排序的核心就是这个break，遇到非逆序时就break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>刷题</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最长上升子序列LIS</title>
    <url>/2022/02/23/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97LIS/</url>
    <content><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一个长度为 n 的数组 arr，求它的最长严格上升子序列的长度。<br>所谓子序列，指一个数组删掉一些数（也可以不删）之后，形成的新数组。例如 [1,5,3,7,3] 数组，其子序列有：[1,3,3]、[7] 等。但 [1,6]、[1,3,5] 则不是它的子序列。</p>
<p> 。<br>数据范围： 0 &lt;= n &lt;= 1000<br>要求：时间复杂度 O(n^2)，空间复杂度 O(n)</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><pre><code>输入：[6,3,1,5,2,3,7]
返回值：4
说明：该数组最长上升子序列为 [1,2,3,7] ，长度为4
</code></pre>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>维护一个伪上升子序列，遍历数组中每一个值，二分找到伪上升子序列中第一个比它大的值，然后将其替换掉，如果没有则直接插入到伪上升子序列最后。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol>
<li><p>手写二分</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> b[n];</span><br><span class="line">    <span class="keyword">int</span> lb, rb;</span><br><span class="line">    lb = rb = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l, r, mid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        l = lb;</span><br><span class="line">        r = rb;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(b[mid]&gt;arr[i]) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=lb&amp;&amp;l&lt;=rb<span class="number">-1</span>) b[l] = arr[i];</span><br><span class="line">        <span class="keyword">else</span> b[rb++] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rb-lb;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>upper_bound</p>
<p> upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p>
<p> lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="built_in">upper_bound</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(),a[i])-b.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">if</span>(p==b.<span class="built_in">size</span>()) b.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        <span class="keyword">else</span> b[p] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>BM65最长公共子序列二</title>
    <url>/2022/02/23/BM65%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定两个字符串str1和str2，输出两个字符串的最长公共子序列。如果最长公共子序列为空，则返回”-1”。目前给出的数据，仅仅会存在一个最长的公共子序列</p>
<p>数据范围：0 &lt;= |str1|,|str2| &lt;= 20000</p>
<p>要求：空间复杂度 O(n^2)，时间复杂度 O(n^2)</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>输入：&quot;1A2C3D4B56&quot;,&quot;B1D23A456A&quot;
返回值：&quot;123456&quot;
</code></pre>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>普通的最长公共子序列只需要返回长度，这道题需要返回子序列，而且受空间复杂度限制不能开二维string数组记录。</p>
<p>需要用dp的结果倒推出子序列。</p>
<p><img src="https://s2.loli.net/2022/02/23/PFUdSlp94ZRIf3N.png" alt="20220223210736"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">LCS</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> l1 = s1.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">int</span> l2 = s2.<span class="built_in">length</span>();</span><br><span class="line">    s1 = <span class="string">&quot;+&quot;</span>+s1;</span><br><span class="line">    s2 = <span class="string">&quot;-&quot;</span>+s2;</span><br><span class="line">    <span class="keyword">int</span> dp[l1+<span class="number">1</span>][l2+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l1;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=l2;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i]==s2[j])&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l1,j=l2;dp[i][j]&gt;=<span class="number">1</span>;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[i]==s2[j])&#123;</span><br><span class="line">            ans = s1[i]+ans;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j]&gt;dp[i][j<span class="number">-1</span>]) i--;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans.<span class="built_in">length</span>()==<span class="number">0</span>) ans = <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>指针和引用的区别</title>
    <url>/2022/02/22/%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><ol>
<li><p>指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。（是否可变）</p>
</li>
<li><p>指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间。（是否占内存）</p>
<p>*引用的实现实际上是占用内存空间的，但程序把它按照不占用内存空间来处理。</p>
<p>实际在内存空间上，引用本身也占用一块内存，里面存储着所引用的变量的地址，大小与指针相同，字面上也表现为unsigned long int型。只是经过编译器处理后，访问这块内存时将直接转而访问其指向的内存。因此在程序中无法读取到这块内存本身。</p>
</li>
<li><p>指针可以为空，但是引用必须绑定对象。（是否可为空）</p>
</li>
<li><p>指针可以有多级，但是引用只能一级。（是否能为多级）</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>友元函数</title>
    <url>/2022/02/21/%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="友元函数的作用"><a href="#友元函数的作用" class="headerlink" title="友元函数的作用"></a>友元函数的作用</h2><p>友元提供了不同类的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制。通过友元，一个不同函数或另一个类中的成员函数可以访问类中的私有成员和保护成员。</p>
<h2 id="private-public-protected的访问范围"><a href="#private-public-protected的访问范围" class="headerlink" title="private,public,protected的访问范围"></a>private,public,protected的访问范围</h2><p>private: 只能由该类中的函数、其友元函数访问,不能被任何其他访问，该类的对象也不能访问</p>
<p>protected: 可以被该类中的函数、子类的函数、以及其友元函数访问,但不能被该类的对象访问</p>
<p>public: 可以被该类中的函数、子类的函数、其友元函数访问,也可以由该类的对象访问</p>
<p>注：友元函数包括两种：设为友元的全局函数，设为友元类中的成员函数</p>
<h2 id="类的继承后方法属性变化"><a href="#类的继承后方法属性变化" class="headerlink" title="类的继承后方法属性变化"></a>类的继承后方法属性变化</h2><p>使用private继承,父类的所有方法在子类中变为private;</p>
<p>使用protected继承,父类的protected和public方法在子类中变为protected,private方法不变;</p>
<p>使用public继承,父类中的方法属性不发生改变;</p>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>实例化一个对象的过程</title>
    <url>/2022/02/21/%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<ol>
<li><p>分配空间</p>
<p> 创建类对象首先要为该对象分配内存空间。不同的对象，为其分配空间的时机未必相同。全局对象、静态对象、分配在栈区域内的对象，在编译阶段进行内存分配；存储在堆空间的对象，是在运行阶段进行内存分配。</p>
</li>
<li><p>初始化</p>
<p> 首先明确一点：初始化不同于赋值。初始化发生在赋值之前，初始化随对象的创建而进行，而赋值是在对象创建好后，为其赋上相应的值。这一点可以联想下上一个问题中提到：初始化列表先于构造函数体内的代码执行，初始化列表执行的是数据成员的初始化过程，这个可以从成员对象的构造函数被调用看的出来。</p>
</li>
<li><p>赋值</p>
<p> 对象初始化完成后，可以对其进行赋值。对于一个类的对象，其成员变量的赋值过程发生在类的构造函数的函数体中。当执行完该函数体，也就意味着类对象的实例化过程完成了。（总结：构造函数实现了对象的初始化和赋值两个过程，对象的初始化是通过初始化列表来完成，而对象的赋值则才是通过构造函数的函数体来实现。）</p>
</li>
</ol>
<p>注：对于拥有虚函数的类的对象，还需要给虚表指针赋值。</p>
<pre><code>没有继承关系的类，分配完内存后，首先给虚表指针赋值，然后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。

有继承关系的类，分配内存之后，首先进行基类的构造过程，然后给该派生类的虚表指针赋值，最后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。
</code></pre>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>c++知识点</title>
    <url>/2022/02/21/c-%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<ol>
<li><p>为什么拷贝构造函数必须为引用？</p>
<p>避免拷贝构造函数无限制的递归，最终导致栈溢出。</p>
<p>因为如果拷贝构造函数的参数不是引用的话，那么就是值传递。而值传递本身又会调用拷贝构造函数，拷贝构造函数又是值传递，值传递又会调用拷贝构造函数……导致无限递归下去。</p>
</li>
<li><p>构造函数的隐式调用</p>
<p> 对已经实例化的对象赋值调用的是赋值函数，对还没实例话的对象赋值调用的是拷贝构造函数，这里使用的就是拷贝构造函数的隐式调用。</p>
<p> 如：</p>
<pre><code> A a;
 a = b; 调用的是赋值函数

 A a(b); 调用的也是拷贝构造函数

 A a = b; 调用的是拷贝构造函数（隐式调用）
</code></pre>
</li>
<li><p>C++类对象的初始化顺序</p>
<p>构造函数调用顺序：</p>
<pre><code> 1. 按照派生类继承基类的顺序，即派生列表中声明的顺序，依次调用基类的构造函数；
 2. 按照派生类中成员变量的声名顺序，依次调用派生类中成员变量所属类的构造函数；
 3. 执行派生类自身的构造函数。
</code></pre>
<p> 综上可以得出，类对象的初始化顺序：基类构造函数–&gt;派生类成员变量的构造函数–&gt;自身构造函数</p>
<p> 注：</p>
<pre><code> 基类构造函数的调用顺序与派生类的派生列表中的顺序有关；
 成员变量的初始化顺序与声明顺序有关；
 析构顺序和构造顺序相反。
</code></pre>
</li>
<li><p>为什么用成员初始化列表会快一些？</p>
<p>原因：用户自定义类型如果使用类初始化列表，直接调用该成员变量对应的构造函数即完成初始化；如果在构造函数中初始化，因为 C++ 规定，对象的成员变量的初始化动作发生在进入构造函数本体之前，那么在执行构造函数的函数体之前首先调用默认的构造函数为成员变量设初值，在进入函数体之后，调用该成员变量对应的构造函数。因此，使用列表初始化会减少调用默认的构造函数的过程，效率高。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>不同层常用的网络协议</title>
    <url>/2022/02/21/%E4%B8%8D%E5%90%8C%E5%B1%82%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>层</th>
<th>协议</th>
<th>用处</th>
</tr>
</thead>
<tbody><tr>
<td>数据链路层</td>
<td>CSMA/CD</td>
<td>载波监听，多点接入，冲突检测</td>
</tr>
<tr>
<td></td>
<td>PPP</td>
<td>用户主机和ISP之间通信</td>
</tr>
<tr>
<td>网络层</td>
<td>IP</td>
<td>建立主机之间的联系</td>
</tr>
<tr>
<td></td>
<td>ARP</td>
<td>地址解析协议，已知IP地址获取MAC地址</td>
</tr>
<tr>
<td></td>
<td>ICMP</td>
<td>网际控制报文协议，封装在IP内，用于更有效地转发IP数据报</td>
</tr>
<tr>
<td>传输层</td>
<td>TCP</td>
<td>建立点对点的可靠的连接</td>
</tr>
<tr>
<td></td>
<td>UDP</td>
<td>无连接，不可靠，及时性好</td>
</tr>
<tr>
<td>应用层</td>
<td>DHCP</td>
<td>动态主机配置协议，用于配置主机的IP地址、子网掩码和网关</td>
</tr>
<tr>
<td></td>
<td>DNS</td>
<td>域名解析协议，用于将域名转换成IP地址</td>
</tr>
<tr>
<td></td>
<td>HTTP, FTP, POP3, SMTP…</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>八股文</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>CSMA/CD</title>
    <url>/2022/02/20/CSMA-CD/</url>
    <content><![CDATA[<h2 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议"></a>CSMA/CD 协议</h2><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p>
<pre><code>多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。
载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。
碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。
</code></pre>
<p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p>
<p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p>
]]></content>
      <tags>
        <tag>八股文</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络体系结构</title>
    <url>/2022/02/20/%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2022/02/20/iNMUoEIyA1uBqkg.png" alt="20220220194032"></p>
<h2 id="五层协议"><a href="#五层协议" class="headerlink" title="五层协议"></a>五层协议</h2><ol>
<li><p>应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</p>
</li>
<li><p>传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</p>
</li>
<li><p>网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</p>
</li>
<li><p>数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</p>
</li>
<li><p>物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p>
</li>
</ol>
<h2 id="七层协议"><a href="#七层协议" class="headerlink" title="七层协议"></a>七层协议</h2><p>七层协议就是把五层协议中的应用层拆分成会话层、表示层和应用层。</p>
<ol>
<li><p>表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</p>
</li>
<li><p>会话层 ：建立及管理会话。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>八股文</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>磁盘管理</title>
    <url>/2022/02/20/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p>读写一个磁盘块的时间的影响因素有：</p>
<pre><code>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）
寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）
实际的数据传输时间
</code></pre>
<p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
<ol>
<li><p>先来先服务</p>
<p> FCFS, First Come First Served</p>
<p> 按照磁盘请求的顺序进行调度。</p>
<p> 优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p>
</li>
<li><p>最短寻道时间优先</p>
<p> SSTF, Shortest Seek Time First</p>
<p> 优先调度与当前磁头所在磁道距离最近的磁道。</p>
<p> 虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</p>
<p> <img src="https://s2.loli.net/2022/02/20/vpGJOkajMPBUnbf.png" alt="20220220155042"></p>
</li>
<li><p>电梯算法</p>
<p> 电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p>
<p> 电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p>
<p> 因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p>
<p> <img src="https://s2.loli.net/2022/02/20/uwMSyHxKlRz1BZc.png" alt="20220220155049"></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>八股文</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>连续中值</title>
    <url>/2022/02/19/%E8%BF%9E%E7%BB%AD%E4%B8%AD%E5%80%BC/</url>
    <content><![CDATA[<h2 id="连续中值"><a href="#连续中值" class="headerlink" title="连续中值"></a>连续中值</h2><p>随机产生数字并传递给一个方法。你能否完成这个方法，在每次产生新值时，寻找当前所有值的中间值（中位数）并保存。</p>
<p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<pre><code>void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。
</code></pre>
<p>示例：</p>
<p>addNum(1)<br>addNum(2)<br>findMedian() -&gt; 1.5<br>addNum(3)<br>findMedian() -&gt; 2</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>数组分两半，左边建大顶堆维护左半部分的最大值，右边建小顶堆维护右半部分的最小值，两个堆顶的均值就是数组的中值。每次插入数据的时候判断一下：</p>
<pre><code>如果要插入的数据比右边小顶堆堆顶小，则插到左边；
如果要插入的数据比左边大顶堆堆顶大，则插到右边；
如果介于二者中间，也插到右边，
</code></pre>
<p>同时要保证右边的小顶堆长度最多比左边的大顶堆大1。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt; &gt;bigheap;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt;smallheap;</span><br><span class="line"></span><br><span class="line"><span class="built_in">MedianFinder</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bigheap.<span class="built_in">size</span>()==<span class="number">0</span>&amp;&amp;smallheap.<span class="built_in">size</span>()&lt;=<span class="number">1</span>) smallheap.<span class="built_in">push</span>(num);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num&lt;smallheap.<span class="built_in">top</span>()) bigheap.<span class="built_in">push</span>(num);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num&gt;bigheap.<span class="built_in">top</span>()) smallheap.<span class="built_in">push</span>(num);</span><br><span class="line">    <span class="keyword">else</span> bigheap.<span class="built_in">push</span>(num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(smallheap.<span class="built_in">size</span>()&gt;bigheap.<span class="built_in">size</span>()+<span class="number">1</span>)&#123;</span><br><span class="line">        bigheap.<span class="built_in">push</span>(smallheap.<span class="built_in">top</span>());</span><br><span class="line">        smallheap.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(bigheap.<span class="built_in">size</span>()&gt;smallheap.<span class="built_in">size</span>())&#123;</span><br><span class="line">        smallheap.<span class="built_in">push</span>(bigheap.<span class="built_in">top</span>());</span><br><span class="line">        bigheap.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(smallheap.<span class="built_in">size</span>()&gt;bigheap.<span class="built_in">size</span>()) <span class="keyword">return</span> smallheap.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>*(smallheap.<span class="built_in">top</span>()+bigheap.<span class="built_in">top</span>())/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
]]></content>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>死锁</title>
    <url>/2022/02/19/%E6%AD%BB%E9%94%81-1/</url>
    <content><![CDATA[<h2 id="死锁定义"><a href="#死锁定义" class="headerlink" title="死锁定义"></a>死锁定义</h2><p>线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行。</p>
<h2 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h2><p>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</p>
<p>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</p>
<p>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</p>
<p>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</p>
<h2 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h2><ol>
<li><p>鸵鸟策略</p>
<p>把头埋在沙子里，假装根本没发生问题。</p>
<p> 因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p>
<p> 当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p>
<p> 大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
</li>
<li><p>死锁预防：破坏死锁的四个条件之一</p>
<p> 破环互斥条件：允许资源共享；</p>
<p> 破环占有和等待条件：一次性分配所有资源，只要缺少一个资源，其它资源也都不给他分配；</p>
<p> 破坏不可抢占：请求新资源得不到时，释放已经保持占有的资源，待以后重新申请；</p>
<p> 破坏环路等待：采用顺序资源分配法，给每个资源编号，进程申请资源的时候按照编号顺序申请，释放的时候则相反；</p>
</li>
<li><p>死锁检测与解除：</p>
<p> 检测死锁：利用死锁原理化简资源分配图检测死锁的存在</p>
<p> 死锁解除：资源剥夺、撤销进程、进程回退</p>
<pre><code> 剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；

 撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。
</code></pre>
</li>
<li><p>死锁避免：死锁避免事先预防策略，但是是采用资源动态分配的过程中，防止系统进入不安全状态，以避免死锁。</p>
<p> 预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入不安全的状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法。</p>
<p> 银行家算法：首先需要定义状态和安全状态的概念。系统的状态是当前给进程分配的资源情况。因此，状态包含两个向量Resource（系统中每种资源的总量）和Available（未分配给进程的每种资源的总量）及两个矩阵Claim（表示进程对资源的需求）和Allocation（表示当前分配给进程的资源）。安全状态是指至少有一个资源分配序列不会导致死锁。当进程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。如果是，同意这个请求；如果不是，阻塞该进程知道同意该请求后系统状态仍然是安全的。</p>
</li>
</ol>
<h2 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h2><p>银行家算法是仿照银行发放贷款时采用的控制方式而设计的一种死锁避免算法，该算法的策略是实现动态避免死锁。</p>
<h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>银行家算法的基本思想是：分配资源之前，判断系统是否安全，如果安全才会进行资源分配。</p>
<p>我们把操作系统看做是银行家，操作系统管理的资源相当于银行家的资金，线程向操作系统请求分配资源就是用户向银行家要贷款。</p>
<p>算法在每次分配资源前需要要求： request &lt; available &amp;&amp; request &lt; needing;</p>
<h3 id="算法实例"><a href="#算法实例" class="headerlink" title="算法实例"></a>算法实例</h3><p>系统中有R1，R2，R3三种资源，在time0时刻，5个线程T0，T1，T2，T3，T4对资源占用和需求的情况如下表，此时系统的可用资源向量为(3,3,2)。求T0时刻系统是否存在安全序列？</p>
<p><img src="https://s2.loli.net/2022/02/19/VkdnsuegCWtRB3Y.png" alt="20220219142642"></p>
<p>我们假设每个线程执行时间为一个时刻。</p>
<p>1、在time0时刻，available(3,3,2) &gt; T1.needing(1,2,2)； 所以T1可以执行，T1执行完毕之后available = T1.allocated(2,0,0) + available(3,3,2) = (5,3,2);</p>
<p><img src="https://s2.loli.net/2022/02/19/VSrsExfi6GpQ78u.png" alt="20220219142719"></p>
<p>2、进入time1时刻，available(5,3,2) &gt; T3.needing(0,1,1)；所以T3可以执行，T3执行完毕之后available = T3.allocated(2,1,1)+available(5,3,2) = (7,4,3)；</p>
<p><img src="https://s2.loli.net/2022/02/19/Yw83SBZubGzjMct.png" alt="20220219142727"></p>
<p>3、进入time2时刻，available(7,4,3) &gt; T4.needing(4,3,1)；所以T4可以执行，T4执行完毕之后available = T4.allocated(0,0,2) + available(7,4,3) = (7,4,5)；</p>
<p><img src="https://s2.loli.net/2022/02/19/C7XSQbAgKFu2Bwc.png" alt="20220219142735"></p>
<p>4、进入time3时刻，available(7,4,5) &gt; T2.needing(6,0,0)；所以T2可以执行，T2指向完毕之后available = T2.allocated(3,0,2) + available(7,4,5) = (10,4,7)；</p>
<p><img src="https://s2.loli.net/2022/02/19/gkcsiXuh7IjYG46.png" alt="20220219142741"></p>
<p>5、进入time4时刻，因为available(10,4,7) &gt; T0.needing(7,4,3)；所以执行T0。完成安全序列。</p>
<p>上面只是安全序列的一个例子，可能还存在其他安全序列。</p>
]]></content>
      <tags>
        <tag>八股文</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>进程通信</title>
    <url>/2022/02/18/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程同步与进程通信很容易混淆，它们的区别在于：</p>
<pre><code>进程同步：控制多个进程按一定顺序执行；

进程通信：进程间传输信息。
</code></pre>
<p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p>
<ol>
<li><p>管道</p>
<p> 它具有以下限制：</p>
<p> 只支持半双工通信（单向交替传输）；<br> 只能在父子进程或者兄弟进程中使用。</p>
</li>
<li><p>FIFO</p>
<p> 也称为命名管道，去除了管道只能在父子进程中使用的限制。</p>
</li>
<li><p>消息队列</p>
<p> 相比于 FIFO，消息队列具有以下优点：</p>
<pre><code> 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；

 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
 
 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。
</code></pre>
</li>
<li><p>信号量</p>
<p> 它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p>
</li>
<li><p>共享存储</p>
<p> 允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p>
<p> 需要使用信号量用来同步对共享存储的访问。</p>
<p> 多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</p>
</li>
<li><p>套接字<br> 与其它通信机制不同的是，它可用于不同机器间的进程通信。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>讨论0218</title>
    <url>/2022/02/18/%E8%AE%A8%E8%AE%BA0218/</url>
    <content><![CDATA[<p>目前的瓶颈：应用场景</p>
<p>有源方案的问题：头上只有两个点，测朝向有局限性</p>
<p>无源方案的问题：只做头部朝向的分类，太小了</p>
<p>都存在的问题：呼吸和心跳融不进头部朝向</p>
<p>卖技术：一个技术能在很多场景应用</p>
<p>卖故事：把一个应用场景的故事讲的很好</p>
]]></content>
      <tags>
        <tag>讨论</tag>
      </tags>
  </entry>
  <entry>
    <title>读者写者问题</title>
    <url>/2022/02/17/%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p>
<p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> samephore;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span>* x)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span>* y)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">samephore count_mutex = <span class="number">1</span>;</span><br><span class="line">samephore data_mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">down</span>(&amp;count_mutex);</span><br><span class="line">        count ++;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">1</span>) <span class="built_in">down</span>(&amp;data_mutex);</span><br><span class="line">        <span class="built_in">up</span>(&amp;count_mutex);</span><br><span class="line">        <span class="comment">//read</span></span><br><span class="line">        <span class="built_in">down</span>(&amp;count_mutex);</span><br><span class="line">        count --;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>) <span class="built_in">up</span>(&amp;data_mutex);</span><br><span class="line">        <span class="built_in">up</span>(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">down</span>(&amp;data_mutex);</span><br><span class="line">        <span class="comment">//write</span></span><br><span class="line">        <span class="built_in">up</span>(&amp;data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此解法中读者是优先的，当存在读者时，写者将被延迟，且只要有一个读者活跃，随后而来的读者都将被允许访问此文件，从而导致写者长时间等待，并有可能出现写者饥饿现象。</p>
<p>增加信号量并修改此程序，让写者与读者平等：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">samephore s = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">down</span>(&amp;s);</span><br><span class="line">        <span class="built_in">down</span>(&amp;count_mutex);</span><br><span class="line">        count ++;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">1</span>) <span class="built_in">down</span>(&amp;data_mutex);</span><br><span class="line">        <span class="built_in">up</span>(&amp;count_mutex);</span><br><span class="line">        <span class="built_in">up</span>(&amp;s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//read</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">down</span>(&amp;count_mutex);</span><br><span class="line">        count --;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>) <span class="built_in">up</span>(&amp;data_mutex);</span><br><span class="line">        <span class="built_in">up</span>(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">down</span>(&amp;s);</span><br><span class="line">        <span class="built_in">down</span>(&amp;data_mutex);</span><br><span class="line">        <span class="comment">//write</span></span><br><span class="line">        <span class="built_in">up</span>(&amp;data_mutex);</span><br><span class="line">        <span class="built_in">up</span>(&amp;s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假设进程队列：R1、W1、W2、R2、R3</p>
<p>当R1刚刚执行完V(s)，W1进程若调度会卡在P(writeblock)，而W2R2R3想要运行，均会卡在P(s)，当R1读完，V(writeblock)完成，W1可以运行，以此类推，R1W1W2R2R3按顺序调度。</p>
]]></content>
      <tags>
        <tag>八股文</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>进程的同步和互斥</title>
    <url>/2022/02/17/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5/</url>
    <content><![CDATA[<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。</p>
<p>进程间的直接制约关系就是源于它们之间的相互合作。例如：上面两个程序可以看成5+3*5中的加法程序和乘法程序。若先执行乘法程序再执行加法程序，则5+3*5=20。这个答案一定是对的吗？其实不然。如果我们想要的答案是40，就要先执行加法程序再执行乘法程序，(5+3)*5=40。我们通过加 () 改变了运算的先后顺序，使先乘除后加减变成了先加减后乘除，这就是一种同步机制。</p>
<h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>互斥亦称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。</p>
<p>例如，在仅有一台打印机的系统中，有两个进程A和进程B，如果进程A需要打印时，系统已将打印机分配给进程B，则进程A必须阻塞。一旦进程B将打印机释放，系统便将进程A唤醒，并将其由阻塞状态变为就绪状态。为禁止两个进程同时进入临界区，同步机制应遵循以下准则：</p>
<pre><code>空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。

忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待。

有限等待：对请求访问的进程，应保证能在有限时间内进入临界区。

让权等待：当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。
</code></pre>
]]></content>
      <tags>
        <tag>八股文</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统基本功能</title>
    <url>/2022/02/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><ol>
<li><p>进程管理</p>
<p> 进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p>
</li>
<li><p>内存管理</p>
<p> 内存分配、地址映射、内存保护与共享、虚拟内存等。</p>
</li>
<li><p>文件管理</p>
<p> 文件存储空间的管理、目录管理、文件读写管理和保护等。</p>
</li>
<li><p>设备管理</p>
<p> 完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</p>
<p> 主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>八股文</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统基本特征</title>
    <url>/2022/02/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><ol>
<li><p>并发</p>
<p> 并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</p>
<p> 并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p>
<p> 操作系统通过引入进程和线程，使得程序能够并发运行。</p>
</li>
<li><p>共享</p>
<p> 共享是指系统中的资源可以被多个并发进程共同使用。</p>
<p> 有两种共享方式：互斥共享和同时共享。</p>
<p> 互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</p>
</li>
<li><p>虚拟</p>
<p> 虚拟技术把一个物理实体转换为多个逻辑实体。</p>
<p> 主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</p>
<p> 多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p>
<p> 虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p>
</li>
<li><p>异步</p>
<p> 异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>八股文</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>马戏团人塔</title>
    <url>/2022/02/17/%E9%A9%AC%E6%88%8F%E5%9B%A2%E4%BA%BA%E5%A1%94/</url>
    <content><![CDATA[<p>有个马戏团正在设计叠罗汉的表演节目，一个人要站在另一人的肩膀上。出于实际和美观的考虑，在上面的人要比下面的人矮一点且轻一点。已知马戏团每个人的身高和体重，请编写代码计算叠罗汉最多能叠几个人。</p>
<p>示例：</p>
<pre><code>输入：height = [65,70,56,75,60,68] weight = [100,150,90,190,95,110]
输出：6
解释：从上往下数，叠罗汉最多能叠 6 层：(56,90), (60,95), (65,100), (68,110), (70,150), (75,190)
</code></pre>
<p>思路:</p>
<pre><code>先按照身高降序按照体重升序排序，然后再对体重做最长下降子序列。
因为数据范围是10000所以n^2的算法不行，需要用栈+二分的方法做。
</code></pre>
<p>代码：</p>
<pre><code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> node &amp;a, <span class="keyword">const</span> node &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.height!=b.height) <span class="keyword">return</span> a.height&gt;b.height;</span><br><span class="line">    <span class="keyword">return</span> a.weight&lt;b.weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bestSeqAtIndex</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height, vector&lt;<span class="keyword">int</span>&gt;&amp; weight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;node&gt; arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        node tmp;</span><br><span class="line">        tmp.height = height[i];</span><br><span class="line">        tmp.weight = weight[i];</span><br><span class="line">        arr.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="comment">//for(int i=0;i&lt;n;i++) cout&lt;&lt;arr[i].height&lt;&lt;&quot; &quot;&lt;&lt;arr[i].weight&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    tmp[<span class="number">0</span>] = arr[<span class="number">0</span>].weight;</span><br><span class="line">    cnt ++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> w = arr[i].weight;</span><br><span class="line">        <span class="keyword">if</span>(w&lt;tmp[cnt<span class="number">-1</span>])&#123;</span><br><span class="line">            tmp[cnt++] = w;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> l,r,mid;</span><br><span class="line">            l = <span class="number">0</span>;</span><br><span class="line">            r = cnt<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(tmp[mid]&gt;w) l = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l&gt;=<span class="number">0</span>&amp;&amp;l&lt;cnt&amp;&amp;tmp[l]&lt;w) tmp[l] = w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for(int j=0;j&lt;cnt;j++) cout&lt;&lt;tmp[j]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br></pre></td></tr></table></figure>
</code></pre>
]]></content>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>MVCC+NextKeyLocks</title>
    <url>/2022/02/17/MVCC-NextKeyLocks/</url>
    <content><![CDATA[<h2 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h2><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。</p>
<p>在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。</p>
<p>脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。</p>
<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><ul>
<li>系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li>
<li>事务版本号 TRX_ID ：事务开始时的系统版本号。</li>
</ul>
<h3 id="Undo-日志"><a href="#Undo-日志" class="headerlink" title="Undo 日志"></a>Undo 日志</h3><p>MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。</p>
<p>例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t(id, x) <span class="keyword">VALUES</span>(<span class="number">1</span>, &quot;a&quot;);</span><br><span class="line">UPDATE t <span class="keyword">SET</span> x<span class="operator">=</span>&quot;b&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">UPDATE t <span class="keyword">SET</span> x<span class="operator">=</span>&quot;c&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>因为没有使用 <code>START TRANSACTION</code> 将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208164808217.png"/> </div><br>

<p>INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID  写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。</p>
<h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>MVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, …}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208171445674.png"/> </div><br>

<p>在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：</p>
<ul>
<li><p>TRX_ID &lt; TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。</p>
</li>
<li><p>TRX_ID &gt; TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。</p>
</li>
<li><p>TRX_ID_MIN &lt;= TRX_ID &lt;= TRX_ID_MAX，需要根据隔离级别再进行判断：</p>
<ul>
<li>提交读：如果 TRX_ID  在 TRX_IDs  列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。</li>
<li>可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</li>
</ul>
</li>
</ul>
<p>在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR  找到下一个快照，再进行上面的判断。</p>
<h3 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h3><h4 id="1-快照读"><a href="#1-快照读" class="headerlink" title="1. 快照读"></a>1. 快照读</h4><p>MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ...;</span><br></pre></td></tr></table></figure>

<h4 id="2-当前读"><a href="#2-当前读" class="headerlink" title="2. 当前读"></a>2. 当前读</h4><p>MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span>;</span><br><span class="line">UPDATE;</span><br><span class="line"><span class="keyword">DELETE</span>;</span><br></pre></td></tr></table></figure>

<p>在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ? lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ? <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure>

<h2 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h2><p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p>
<p>MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p>
<h3 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h3><p>锁定一个记录上的索引，而不是记录本身。</p>
<p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p>
<h3 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h3><p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">FOR</span> UPDATE;</span><br></pre></td></tr></table></figure>

<h3 id="Next-Key-Locks-1"><a href="#Next-Key-Locks-1" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h3><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(<span class="operator">-</span>∞, <span class="number">10</span>]</span><br><span class="line">(<span class="number">10</span>, <span class="number">11</span>]</span><br><span class="line">(<span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line">(<span class="number">13</span>, <span class="number">20</span>]</span><br><span class="line">(<span class="number">20</span>, <span class="operator">+</span>∞)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>八股文</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>关系数据库设计理论</title>
    <url>/2022/02/17/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<p>关系数据库设计理论</p>
<h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p>
<p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p>
<p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p>
<p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p>
<table>
<thead>
<tr>
<th align="center">Sno</th>
<th align="center">Sname</th>
<th align="center">Sdept</th>
<th align="center">Mname</th>
<th align="center">Cname</th>
<th align="center">Grade</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">学生-1</td>
<td align="center">学院-1</td>
<td align="center">院长-1</td>
<td align="center">课程-1</td>
<td align="center">90</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">学生-2</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
<td align="center">课程-2</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">学生-2</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
<td align="center">课程-1</td>
<td align="center">100</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">学生-3</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
<td align="center">课程-2</td>
<td align="center">95</td>
</tr>
</tbody></table>
<p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p>
<ul>
<li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li>
<li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li>
<li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li>
<li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li>
</ul>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>范式理论是为了解决以上提到四种异常。</p>
<p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p>
<h4 id="1-第一范式-1NF"><a href="#1-第一范式-1NF" class="headerlink" title="1. 第一范式 (1NF)"></a>1. 第一范式 (1NF)</h4><p>属性不可分。</p>
<h4 id="2-第二范式-2NF"><a href="#2-第二范式-2NF" class="headerlink" title="2. 第二范式 (2NF)"></a>2. 第二范式 (2NF)</h4><p>每个非主属性完全函数依赖于键码。</p>
<p>可以通过分解来满足。</p>
<p><strong>分解前</strong>:</p>
<table>
<thead>
<tr>
<th align="center">Sno</th>
<th align="center">Sname</th>
<th align="center">Sdept</th>
<th align="center">Mname</th>
<th align="center">Cname</th>
<th align="center">Grade</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">学生-1</td>
<td align="center">学院-1</td>
<td align="center">院长-1</td>
<td align="center">课程-1</td>
<td align="center">90</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">学生-2</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
<td align="center">课程-2</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">学生-2</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
<td align="center">课程-1</td>
<td align="center">100</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">学生-3</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
<td align="center">课程-2</td>
<td align="center">95</td>
</tr>
</tbody></table>
<p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
<li>Sno, Cname-&gt; Grade</li>
</ul>
<p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p>
<p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p>
<p><strong>分解后</strong>:</p>
<p>关系-1</p>
<table>
<thead>
<tr>
<th align="center">Sno</th>
<th align="center">Sname</th>
<th align="center">Sdept</th>
<th align="center">Mname</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">学生-1</td>
<td align="center">学院-1</td>
<td align="center">院长-1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">学生-2</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">学生-3</td>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
</tr>
</tbody></table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
</ul>
<p>关系-2</p>
<table>
<thead>
<tr>
<th align="center">Sno</th>
<th align="center">Cname</th>
<th align="center">Grade</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">课程-1</td>
<td align="center">90</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">课程-2</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">课程-1</td>
<td align="center">100</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">课程-2</td>
<td align="center">95</td>
</tr>
</tbody></table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno, Cname -&gt;  Grade</li>
</ul>
<h4 id="3-第三范式-3NF"><a href="#3-第三范式-3NF" class="headerlink" title="3. 第三范式 (3NF)"></a>3. 第三范式 (3NF)</h4><p>非主属性不传递函数依赖于键码。</p>
<p>上面的 关系-1 中存在以下传递函数依赖：</p>
<ul>
<li>Sno -&gt; Sdept -&gt; Mname</li>
</ul>
<p>可以进行以下分解：</p>
<p>关系-11</p>
<table>
<thead>
<tr>
<th align="center">Sno</th>
<th align="center">Sname</th>
<th align="center">Sdept</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">学生-1</td>
<td align="center">学院-1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">学生-2</td>
<td align="center">学院-2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">学生-3</td>
<td align="center">学院-2</td>
</tr>
</tbody></table>
<p>关系-12</p>
<table>
<thead>
<tr>
<th align="center">Sdept</th>
<th align="center">Mname</th>
</tr>
</thead>
<tbody><tr>
<td align="center">学院-1</td>
<td align="center">院长-1</td>
</tr>
<tr>
<td align="center">学院-2</td>
<td align="center">院长-2</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>八股文</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>封锁</title>
    <url>/2022/02/16/%E5%B0%81%E9%94%81/</url>
    <content><![CDATA[<h2 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h2><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p>
<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p>
<p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p>
<p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>
<h2 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h2><ol>
<li><p>读写锁</p>
<p> 互斥锁（Exclusive），简写为 X 锁，又称写锁。</p>
<p> 共享锁（Shared），简写为 S 锁，又称读锁。</p>
<p> 有以下两个规定：</p>
<p> 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</p>
<p> 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</p>
</li>
<li><p>意向锁</p>
<p> 使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p>
<p> 在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>
<p> 意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>
<p> 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</p>
<p> 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</p>
<p> 通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>
<p> 解释如下：</p>
<p> 任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；<br> 这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</p>
</li>
</ol>
<h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><ol>
<li><p>三级封锁协议</p>
<ol>
<li><p>一级封锁协议</p>
<p> 事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p>
<p> 可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p>
</li>
<li><p>二级封锁协议</p>
<p> 在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p>
<p> 可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p>
</li>
<li><p>三级封锁协议</p>
<p> 在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p>
<p> 可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p>
</li>
</ol>
</li>
<li><p>两段锁协议<br> 加锁和解锁分为两个阶段进行。</p>
<p> 可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p>
<p> 事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p>
<pre><code> lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
</code></pre>
<p> 但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。</p>
<pre><code> lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
</code></pre>
</li>
</ol>
]]></content>
      <tags>
        <tag>八股文</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>并发一致性</title>
    <url>/2022/02/16/%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    <content><![CDATA[<h2 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h2><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>
<ol>
<li><p>丢失修改<br> 丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p>
</li>
<li><p>读脏数据<br> 读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p>
</li>
<li><p>不可重复读<br> 不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
</li>
<li><p>幻影读<br> 幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
</li>
</ol>
<p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>
]]></content>
      <tags>
        <tag>八股文</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>事务ACID</title>
    <url>/2022/02/16/%E4%BA%8B%E5%8A%A1ACID/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>
<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><ol>
<li><p>原子性（Atomicity）</p>
<p> 事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>
<p> 回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>
</li>
<li><p>一致性（Consistency）</p>
<p> 数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</p>
</li>
<li><p>隔离性（Isolation）</p>
<p> 一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p>
</li>
<li><p>持久性（Durability）</p>
<p> 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>
<p> 系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p>
</li>
</ol>
<p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p>
<p>只有满足一致性，事务的执行结果才是正确的。</p>
<p>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</p>
<p>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</p>
<p>事务满足持久化是为了能应对系统崩溃的情况。</p>
]]></content>
      <tags>
        <tag>八股文</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>柱状图中最大的矩形</title>
    <url>/2022/02/16/%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p>示例：</p>
<p><img src="https://s2.loli.net/2022/02/16/sTSw6JUKRNqjDyV.png" alt="20220216152744"></p>
<p>输入：heights = [2,1,5,6,2,3]</p>
<p>输出：10</p>
<p>解释：最大的矩形为图中红色区域，面积为 10</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>遍历每个柱子，以该柱子的高度为矩形高度，并寻找每个柱子左边和右边最后一个高于它的柱子的位置作为左右矩形边界。</p>
<h2 id="解法1：单调栈"><a href="#解法1：单调栈" class="headerlink" title="解法1：单调栈"></a>解法1：单调栈</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">lb</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rb</span><span class="params">(n, n<span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!sta.<span class="built_in">empty</span>()&amp;&amp;heights[i]&lt;heights[sta.<span class="built_in">top</span>()])&#123;</span><br><span class="line">            rb[sta.<span class="built_in">top</span>()] = i<span class="number">-1</span>;</span><br><span class="line">            sta.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        sta.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    sta.<span class="built_in">pop</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!sta.<span class="built_in">empty</span>()&amp;&amp;heights[i]&lt;heights[sta.<span class="built_in">top</span>()])&#123;</span><br><span class="line">            lb[sta.<span class="built_in">top</span>()] = i+<span class="number">1</span>;</span><br><span class="line">            sta.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        sta.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    sta.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) ans = <span class="built_in">max</span>(ans, heights[i]*(rb[i]-lb[i]+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2：线段树"><a href="#解法2：线段树" class="headerlink" title="解法2：线段树"></a>解法2：线段树</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">int</span> tree[<span class="number">1000000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[p] = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(p*<span class="number">2</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    tree[p] = <span class="built_in">min</span>(tree[p*<span class="number">2</span>], tree[p*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(y&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(p*<span class="number">2</span>,l,mid,x,y);</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=mid+<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">query</span>(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">query</span>(p*<span class="number">2</span>,l,mid,x,y),<span class="built_in">query</span>(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">    a = heights;</span><br><span class="line">    <span class="keyword">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">max</span>(heights[<span class="number">0</span>], heights[n<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lm,rm,lb,rb;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;i&lt;&lt;&quot;: (&quot;&lt;&lt;heights[i]&lt;&lt;&quot;) &quot;;</span></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>) lm = heights[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> lm = <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(lm&gt;=heights[i])&#123;</span><br><span class="line">            lb = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> l, r, mid;</span><br><span class="line">            l = <span class="number">0</span>;</span><br><span class="line">            r = i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">0</span>,n<span class="number">-1</span>,mid+<span class="number">1</span>,r)&lt;heights[i])&#123;</span><br><span class="line">                    l = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    r = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lb = l+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i==n<span class="number">-1</span>) rm = heights[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span> rm = <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">0</span>,n<span class="number">-1</span>,i+<span class="number">1</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(rm&gt;=heights[i])&#123;</span><br><span class="line">            rb = n<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> l, r, mid;</span><br><span class="line">            l = i+<span class="number">1</span>;</span><br><span class="line">            r = n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">0</span>,n<span class="number">-1</span>,l,mid)&lt;heights[i])&#123;</span><br><span class="line">                    r = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    l = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            rb = l<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, heights[i]*(rb-lb+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>手写优先队列</title>
    <url>/2022/02/16/%E6%89%8B%E5%86%99%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>用数组实现大/小顶堆，子节点=父节点*2或者*2+1。</p>
<p>用数组构造二叉树，push元素时先存到最后一个节点，然后从最后一个节点迭代与父节点比较交换，一直到第一个节点或者停止交换。</p>
<p>pop时直接交换第一个节点和最后一个节点，然后从第一个节点迭代与两个子节点中较大/小的那个比较交换，一直到最后一层节点或者停止交换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> siz;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    a[++siz] = x;</span><br><span class="line">    <span class="keyword">int</span> son = siz;</span><br><span class="line">    <span class="keyword">int</span> par = son/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(par&gt;=<span class="number">1</span>)&#123; </span><br><span class="line">        <span class="keyword">if</span>(a[son]&gt;a[par])&#123; <span class="comment">// 小顶堆为 &lt; </span></span><br><span class="line">            <span class="built_in">swap</span>(a[son], a[par]);</span><br><span class="line">            son = par;</span><br><span class="line">            par = son/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a[<span class="number">1</span>] = a[siz--];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> par = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> son = par*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(son&lt;=siz)&#123;</span><br><span class="line">        <span class="keyword">if</span>(son+<span class="number">1</span>&lt;=siz&amp;&amp;a[son+<span class="number">1</span>]&gt;a[son])&#123; <span class="comment">// 小顶堆为 &lt; </span></span><br><span class="line">            son ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[son]&gt;a[par])&#123; <span class="comment">// 小顶堆为 &lt; </span></span><br><span class="line">            <span class="built_in">swap</span>(a[son], a[par]);</span><br><span class="line">            par = son;</span><br><span class="line">            son = par*<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    siz = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>多态</title>
    <url>/2022/02/15/%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。在基类的函数前加上 virtual 关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。<br>实现方法：多态是通过虚函数实现的，虚函数的地址保存在虚函数表中，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中。</p>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>在类中用 virtual 关键字声明的函数叫做虚函数；<br>存在虚函数的类都有一个虚函数表，当创建一个该类的对象时，该对象有一个指向虚函数表的虚表指针（虚函数表和类对应的，虚表指针是和对象对应）；<br>当基类指针指向派生类对象，基类指针调用虚函数时，基类指针指向派生类的虚表指针，由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数。</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::fun()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">    p-&gt;<span class="built_in">fun</span>(); <span class="comment">// Derive::fun() 调用派生类中的虚函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基类的虚函数表如下：</p>
<p><img src="https://s2.loli.net/2022/02/15/Hexf8Qkly71Fqn2.png" alt="20220215171346"></p>
<p>派生类的对象虚函数表如下：</p>
<p><img src="https://s2.loli.net/2022/02/15/YqVBLIPJpWHlM2y.png" alt="20220215171352"></p>
<p>简单解释：当基类的指针指向派生类的对象时，通过派生类的对象的虚表指针找到虚函数表（派生类的对象虚函数表），进而找到相应的虚函数 Derive::f() 进行调用。</p>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题记录</title>
    <url>/2022/02/15/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="03-14"><a href="#03-14" class="headerlink" title="03/14"></a>03/14</h2><p>【2021】阿里巴巴编程题 1.子集</p>
<p>【2021】阿里巴巴编程题 2.小强爱数学</p>
<p>【2021】阿里巴巴编程题 3.二叉树</p>
<p>【2021】阿里巴巴编程题 4.对称飞行器</p>
<p>【2021】阿里巴巴编程题 6.树上最短链</p>
<p>【2021】阿里巴巴编程题 7.牛牛们吃糖果</p>
<p>【2021】阿里巴巴编程题 8.方案数量</p>
<p>【2021】阿里巴巴编程题 9.合法连续子段</p>
<h2 id="03-12"><a href="#03-12" class="headerlink" title="03/12"></a>03/12</h2><p>424.替换后的最长重复字符</p>
<h2 id="03-11"><a href="#03-11" class="headerlink" title="03/11"></a>03/11</h2><p>25.K 个一组翻转链表</p>
<h2 id="03-10"><a href="#03-10" class="headerlink" title="03/10"></a>03/10</h2><p>剑指 Offer 25. 合并两个排序的链表</p>
<p>NC142 最长重复子串</p>
<p>NC73 数组中出现次数超过一半的数字</p>
<p>208.实现 Trie (前缀树)</p>
<h2 id="03-09"><a href="#03-09" class="headerlink" title="03/09"></a>03/09</h2><p>120.三角形最小路径和</p>
<p>329.矩阵中的最长递增路径</p>
<p>343.整数拆分</p>
<h2 id="03-08"><a href="#03-08" class="headerlink" title="03/08"></a>03/08</h2><p>18.四数之和</p>
<h2 id="03-06"><a href="#03-06" class="headerlink" title="03/06"></a>03/06</h2><p>131.分割回文串</p>
<p>132.分割回文串 II</p>
<p>233.数字 1 的个数</p>
<p>264.丑数 II</p>
<p>313.超级丑数</p>
<h2 id="03-04"><a href="#03-04" class="headerlink" title="03/04"></a>03/04</h2><p>剑指 Offer 24. 反转链表</p>
<p>160.相交链表</p>
<h2 id="03-03"><a href="#03-03" class="headerlink" title="03/03"></a>03/03</h2><p>322.零钱兑换</p>
<p>337.打家劫舍 III</p>
<p>416.分割等和子集</p>
<p>338.比特位计数</p>
<p>72.编辑距离</p>
<p>213.打家劫舍 II</p>
<h2 id="03-02"><a href="#03-02" class="headerlink" title="03/02"></a>03/02</h2><p>152.乘积最大子数组</p>
<p>221.最大正方形</p>
<p>279.完全平方数</p>
<p>300.最长递增子序列</p>
<p>121.买卖股票的最佳时机</p>
<p>122.买卖股票的最佳时机 II</p>
<p>123.买卖股票的最佳时机 III</p>
<p>188.买卖股票的最佳时机 IV</p>
<p>309.最佳买卖股票时机含冷冻期</p>
<p>714.买卖股票的最佳时机含手续费</p>
<h2 id="03-01"><a href="#03-01" class="headerlink" title="03/01"></a>03/01</h2><p>1091.二进制矩阵中的最短路径</p>
<p>1129.颜色交替的最短路径</p>
<p>102.二叉树的层序遍历</p>
<p>101.对称二叉树</p>
<p>752.打开转盘锁</p>
<h2 id="02-28"><a href="#02-28" class="headerlink" title="02/28"></a>02/28</h2><p>105.从前序与中序遍历序列构造二叉树</p>
<p>112.路径总和</p>
<p>98.验证二叉搜索树</p>
<p>494.目标和</p>
<p>547.省份数量</p>
<p>1254.统计封闭岛屿的数目</p>
<h2 id="02-27"><a href="#02-27" class="headerlink" title="02/27"></a>02/27</h2><p>47.全排列 II</p>
<p>406.根据身高重建队列</p>
<p>899.有序队列</p>
<p>946.验证栈序列</p>
<p>116.填充每个节点的下一个右侧节点指针</p>
<p>895.最大频率栈 *</p>
<p>61.旋转链表</p>
<p>729.我的日程安排表 I</p>
<p>25.K 个一组翻转链表</p>
<p>554.砖墙</p>
<p>112.路径总和</p>
<h2 id="02-26"><a href="#02-26" class="headerlink" title="02/26"></a>02/26</h2><p>剑指 Offer II 051. 节点之和最大的路径</p>
<p>409.最长回文串</p>
<p>5.最长回文子串</p>
<p>214.最短回文串*</p>
<h2 id="02-24"><a href="#02-24" class="headerlink" title="02/24"></a>02/24</h2><p>3.无重复字符的最长子串</p>
<p>剑指 Offer II 016. 不含重复字符的最长子字符串</p>
<p>49.字母异位词分组</p>
<p>30.串联所有单词的子串</p>
<p>86.分隔链表</p>
<p>16.最接近的三数之和</p>
<p>732.我的日程安排表 III</p>
<p>731.我的日程安排表 II</p>
<p>729.我的日程安排表 I</p>
<h2 id="02-23"><a href="#02-23" class="headerlink" title="02/23"></a>02/23</h2><p>剑指 Offer 14- I. 剪绳子</p>
<p>115.不同的子序列</p>
<p>139.单词拆分</p>
<p>140.单词拆分 II</p>
<h2 id="02-22"><a href="#02-22" class="headerlink" title="02/22"></a>02/22</h2><p>面试题 16.24. 数对和</p>
<p>面试题 17.05.  字母与数字</p>
<p>面试题 17.11. 单词距离</p>
<p>面试题 17.16. 按摩师</p>
<h2 id="02-21"><a href="#02-21" class="headerlink" title="02/21"></a>02/21</h2><p>面试题 04.01. 节点间通路</p>
<p>面试题 04.05. 合法二叉搜索树</p>
<p>面试题 04.06. 后继者</p>
<p>面试题 04.08. 首个共同祖先</p>
<p>面试题 08.02. 迷路的机器人</p>
<h2 id="02-20"><a href="#02-20" class="headerlink" title="02/20"></a>02/20</h2><p>面试题 17.23. 最大黑方阵</p>
<p>面试题 17.24. 最大子矩阵</p>
<p>面试题 03.05. 栈排序</p>
<p>面试题 10.10. 数字流的秩</p>
<h2 id="02-19"><a href="#02-19" class="headerlink" title="02/19"></a>02/19</h2><p>面试题 17.19. 消失的两个数字</p>
<p>面试题 17.20. 连续中值</p>
<h2 id="02-18"><a href="#02-18" class="headerlink" title="02/18"></a>02/18</h2><p>面试题 17.09. 第 k 个数</p>
<p>面试题 17.18. 最短超串</p>
<p>面试题 17.21. 直方图的水量</p>
<h2 id="02-17"><a href="#02-17" class="headerlink" title="02/17"></a>02/17</h2><p>面试题 03.03. 堆盘子</p>
<p>面试题 08.11. 硬币</p>
<p>面试题 10.11. 峰与谷</p>
<p>面试题 17.14. 最小K个数</p>
<p>面试题 17.08. 马戏团人塔</p>
<h2 id="02-16"><a href="#02-16" class="headerlink" title="02/16"></a>02/16</h2><p>剑指 Offer 34. 二叉树中和为某一值的路径</p>
<p>剑指 Offer 33. 二叉搜索树的后序遍历序列</p>
<p>面试题32 - I. 从上到下打印二叉树</p>
<p>剑指 Offer 44. 数字序列中某一位的数字  </p>
<p>84.柱状图中最大的矩形</p>
<h2 id="02-15"><a href="#02-15" class="headerlink" title="02/15"></a>02/15</h2><p>剑指Offer26.树的子结构</p>
<p>剑指Offer16.数值的整数次方</p>
<p>剑指Offer35.复杂链表的复制</p>
<p>剑指Offer36.二叉搜索树与双向链表</p>
<p>剑指Offer31.栈的压入、弹出序列</p>
<p>剑指Offer38.字符串的排列</p>
<p>剑指Offer32-III.从上到下打印二叉树III</p>
<p>641.设计循环双端队列</p>
<h2 id="02-14"><a href="#02-14" class="headerlink" title="02/14"></a>02/14</h2><p>剑指Offer04.二维数组中的查找</p>
<p>剑指Offer12.矩阵中的路径</p>
<p>剑指Offer13.机器人的运动范围</p>
<p>剑指Offer07.重建二叉树</p>
<p>剑指Offer14-I.剪绳子</p>
<p>面试题16.25.LRU缓存</p>
<h2 id="02-13"><a href="#02-13" class="headerlink" title="02/13"></a>02/13</h2><p>剑指Offer48.最长不含重复字符的子字符串</p>
<p>剑指Offer49.丑数</p>
<p>剑指Offer59-I.滑动窗口的最大值</p>
<p>剑指Offer59-II.队列的最大值</p>
<p>剑指Offer66.构建乘积数组</p>
<p>剑指Offer60.n个骰子的点数</p>
<p>剑指Offer67.把字符串转换成整数</p>
<p>剑指Offer63.股票的最大利润</p>
<p>剑指Offer64.求1+2+…+n</p>
<p>剑指Offer56-I.数组中数字出现的次数</p>
<h2 id="02-12"><a href="#02-12" class="headerlink" title="02/12"></a>02/12</h2><p>剑指Offer45.把数组排成最小的数</p>
<p>剑指Offer46.把数字翻译成字符串</p>
<p>剑指Offer47.礼物的最大价值</p>
<h2 id="12-30"><a href="#12-30" class="headerlink" title="12/30"></a>12/30</h2><p>112.最长递增路径</p>
<p>114.外星文字典</p>
<h2 id="12-29"><a href="#12-29" class="headerlink" title="12/29"></a>12/29</h2><p>632.最小区间</p>
<p>094.最少回文分割</p>
<h2 id="12-28"><a href="#12-28" class="headerlink" title="12/28"></a>12/28</h2><p>543.二叉树的直径</p>
<p>435.无重叠区间</p>
<p>51.数组中的逆序对</p>
<h2 id="12-27"><a href="#12-27" class="headerlink" title="12/27"></a>12/27</h2><p>206.反转链表</p>
<p>1312.让字符串成为回文串的最少插入次数</p>
<h2 id="12-23"><a href="#12-23" class="headerlink" title="12/23"></a>12/23</h2><p>5.最长回文子串</p>
<p>647.回文子串</p>
<p>409.最长回文串</p>
<h2 id="12-18"><a href="#12-18" class="headerlink" title="12/18"></a>12/18</h2><p>121.买卖股票的最佳时机</p>
<p>122.买卖股票的最佳时机II</p>
<p>123.买卖股票的最佳时机III</p>
<p>188.买卖股票的最佳时机IV</p>
<h2 id="12-16"><a href="#12-16" class="headerlink" title="12/16"></a>12/16</h2><p>049.从根节点到叶节点的路径数字之和</p>
<p>050.向下的路径节点之和</p>
<p>051.节点之和最大的路径</p>
<p>052.展平二叉搜索树</p>
<p>055.二叉搜索树迭代器</p>
<p>056.二叉搜索树中两个节点之和</p>
<p>012.左右两边子数组的和相等</p>
<h2 id="12-15"><a href="#12-15" class="headerlink" title="12/15"></a>12/15</h2><p>043.往完全二叉树添加节点</p>
<p>044.二叉树每层的最大值</p>
<p>045.二叉树最底层最左边的值</p>
<p>046.二叉树的右侧视图</p>
<p>047.二叉树剪枝</p>
<p>039.直方图最大矩形面积</p>
<p>040.矩阵中最大的矩形</p>
<h2 id="12-14"><a href="#12-14" class="headerlink" title="12/14"></a>12/14</h2><p>033.变位词组</p>
<h2 id="12-13"><a href="#12-13" class="headerlink" title="12/13"></a>12/13</h2><p>095.最长公共子序列</p>
<p>096.字符串交织</p>
<p>036.后缀表达式</p>
<p>030.插入、删除和随机访问都是O(1)的容器</p>
<p>029.排序的循环链表</p>
<p>099.最小路径之和</p>
<p>106.二分图</p>
<p>093.最长斐波那契数列*</p>
<p>107.矩阵中的距离</p>
<p>113.课程顺序</p>
<h2 id="12-12"><a href="#12-12" class="headerlink" title="12/12"></a>12/12</h2><p>767.重构字符串</p>
<p>153.寻找旋转排序数组中的最小值</p>
<p>969.煎饼排序</p>
<h2 id="12-11"><a href="#12-11" class="headerlink" title="12/11"></a>12/11</h2><p>092.翻转字符</p>
<p>083.没有重复元素集合的全排列</p>
<p>084.含有重复元素集合的全排列</p>
<p>085.生成匹配的括号</p>
<p>007.数组中和为0的三个数</p>
<p>014.字符串中的变位词</p>
<p>031.最近最少使用缓存</p>
<h2 id="12-10"><a href="#12-10" class="headerlink" title="12/10"></a>12/10</h2><p>090.环形房屋偷盗</p>
<p>035.最小时间差</p>
<p>010.和为k的子数组前缀和+哈希优化</p>
<h2 id="12-9"><a href="#12-9" class="headerlink" title="12/9"></a>12/9</h2><p>057.值和下标之差都在给定的范围内桶</p>
<p>058.日程表</p>
<p>059.数据流的第K大数值</p>
<p>060.出现频率最高的k个数字</p>
<p>061.和最小的k个数对</p>
<p>073.狒狒吃香蕉</p>
<p>116.省份数量</p>
<p>071.按权重生成随机数</p>
<h2 id="12-8"><a href="#12-8" class="headerlink" title="12/8"></a>12/8</h2><p>038.每日温度</p>
<p>100.三角形中最小路径之和</p>
<p>102.加减的目标值</p>
<p>103.最少的硬币数目</p>
<p>105.岛屿的最大面积</p>
<p>109.开密码锁</p>
<p>292.Nim游戏</p>
<p>118.多余的边</p>
<h2 id="12-7"><a href="#12-7" class="headerlink" title="12/7"></a>12/7</h2><p>027.回文链表</p>
<p>072.求平方根</p>
<p>081.允许重复选择元素的组合</p>
<p>003.前n个数字二进制中1的个数</p>
<p>082.含有重复元素集合的组合</p>
<p>005.单词长度的最大乘积</p>
<p>008.和大于等于target的最短子数组</p>
<p>088.爬楼梯的最少成本</p>
<p>009.乘积小于K的子数组</p>
<p>089.房屋偷盗</p>
<p>011.0和1个数相同的子数组</p>
<p>013.二维子矩阵的和</p>
<p>091.粉刷房子</p>
<p>037.小行星碰撞</p>
<h2 id="12-6"><a href="#12-6" class="headerlink" title="12/6"></a>12/6</h2><p>815.公交路线</p>
<p>909.蛇梯棋</p>
<p>529.扫雷游戏</p>
<p>934.最短的桥</p>
<p>146.LRU缓存机制</p>
<h2 id="12-4"><a href="#12-4" class="headerlink" title="12/4"></a>12/4</h2><p>1293.网格中的最短路径三维BFS</p>
<p>141.环形链表</p>
<p>142.环形链表II</p>
<h2 id="12-3"><a href="#12-3" class="headerlink" title="12/3"></a>12/3</h2><p>80.删除有序数组中的重复项II</p>
<p>1162.地图分析BFS</p>
<p>743.网络延迟时间Dijkstra</p>
<h2 id="12-2"><a href="#12-2" class="headerlink" title="12/2"></a>12/2</h2><p>77.组合</p>
<p>70.爬楼梯</p>
<p>79.单词搜索</p>
<p>89.格雷编码</p>
<p>90.子集II</p>
<p>91.解码方法</p>
<p>92.反转链表II</p>
<p>93.复原IP地址</p>
<p>96.不同的二叉搜索树</p>
<p>97.交错字符串dp*********</p>
<h2 id="12-1"><a href="#12-1" class="headerlink" title="12/1"></a>12/1</h2><p>214.最短回文串哈希/KMP</p>
<p>312.戳气球区间dp</p>
<p>7.整数反转</p>
<p>8.字符串转换整数(atoi)</p>
<p>12.整数转罗马数字</p>
<p>63.不同路径II</p>
<p>38.外观数列</p>
<p>40.组合总和II</p>
<h2 id="11-30"><a href="#11-30" class="headerlink" title="11/30"></a>11/30</h2><p>149.直线上最多的点数</p>
<p>174.地下城游戏逆向dp</p>
<p>20.有效的括号栈</p>
<p>27.移除元素</p>
<p>124.二叉树中的最大路径和树上dp</p>
<p>底层const和顶层const</p>
<p>164.最大间距计数排序</p>
<h2 id="11-29"><a href="#11-29" class="headerlink" title="11/29"></a>11/29</h2><p>123.买卖股票的最佳时机IIIdp</p>
<p>135.分发糖果</p>
<h2 id="11-26"><a href="#11-26" class="headerlink" title="11/26"></a>11/26</h2><p>57插图区间什么破题？？？闭区间还是开区间都没说清楚。。</p>
<p>45跳跃游戏经典dp</p>
<p>50Pow经典快速幂</p>
<h2 id="11-25"><a href="#11-25" class="headerlink" title="11/25"></a>11/25</h2><p>44通配符匹配</p>
<p>32最长有效括号</p>
<p>51+52N皇后</p>
<p>60排列序列**********</p>
<p>65有效数字</p>
<p>84柱状图中最大的矩形</p>
<h2 id="11-24"><a href="#11-24" class="headerlink" title="11/24"></a>11/24</h2><p>301？？？？？剪枝就愣是剪不过去？？？</p>
<p>41缺失的第一个正数有点意思</p>
<p>42接雨水</p>
<h2 id="11-23"><a href="#11-23" class="headerlink" title="11/23"></a>11/23</h2><p>1.数之和</p>
<p>2.两数相加</p>
<p>3.无重复字符的最长子串</p>
<p>4.寻找两个正序数组的中位数</p>
<p>5.最长回文子串</p>
<p>15.三数之和</p>
<p>72.编辑距离</p>
<p>239.滑动窗口最大值</p>
]]></content>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>重载，覆盖，重写</title>
    <url>/2022/02/14/%E9%87%8D%E8%BD%BD%EF%BC%8C%E8%A6%86%E7%9B%96%EF%BC%8C%E9%87%8D%E5%86%99/</url>
    <content><![CDATA[<ol>
<li><p>重载：是指同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">float</span> tmp)</span></span>;        <span class="comment">// 重载 参数类型不同（相对于上一个函数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp, <span class="keyword">float</span> tmp1)</span></span>; <span class="comment">// 重载 参数个数不同（相对于上一个函数）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">float</span> tmp, <span class="keyword">int</span> tmp1)</span></span>; <span class="comment">// 重载 参数顺序不同（相对于上一个函数）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span></span>;            <span class="comment">// error: &#x27;int A::fun(int)&#x27; cannot be overloaded 错误：注意重载不关心函数返回类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>隐藏：是指派生类的函数屏蔽了与其同名的基类函数，只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp, <span class="keyword">float</span> tmp1)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun(int tmp, float tmp1)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::fun(int tmp)&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// 隐藏基类中的同名函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derive ex;</span><br><span class="line">    ex.<span class="built_in">fun</span>(<span class="number">1</span>);       <span class="comment">// Derive::fun(int tmp)</span></span><br><span class="line">    ex.<span class="built_in">fun</span>(<span class="number">1</span>, <span class="number">0.01</span>); <span class="comment">// error: candidate expects 1 argument, 2 provided</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 说明：上述代码中 ex.fun(1, 0.01); 出现错误，说明派生类中将基类的同名函数隐藏了。若是想调用基类中的同名函数，可以加上类型名指明 ex.Base::fun(1, 0.01);，这样就可以调用基类中的同名函数。</p>
</li>
<li><p>重写(覆盖)：虚函数的应用。是指派生类中存在重新定义的函数。函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有 virtual 修饰。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun(int tmp) : &quot;</span> &lt;&lt; tmp &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::fun(int tmp) : &quot;</span> &lt;&lt; tmp &lt;&lt; endl; &#125; <span class="comment">// 重写基类中的 fun 函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    p-&gt;<span class="built_in">fun</span>(<span class="number">3</span>); <span class="comment">// Derived::fun(int) : 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>重写和重载的区别：</p>
<ol>
<li><p>范围区别：对于类中函数的重载或者重写而言，重载发生在同一个类的内部，重写发生在不同的类之间（子类和父类之间）。</p>
</li>
<li><p>参数区别：重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要和原函数相同，父类中被重写的函数需要有 virtual 修饰。</p>
</li>
<li><p>virtual 关键字：重写的函数基类中必须有 virtual关键字的修饰，重载的函数可以有 virtual 关键字的修饰也可以没有。</p>
</li>
</ol>
<p>隐藏和重写，重载的区别：</p>
<ol>
<li><p>范围区别：隐藏与重载范围不同，隐藏发生在不同类中。</p>
</li>
<li><p>参数区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被 virtual 修饰，基类函数都是被隐藏，而不是重写。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针实现原理</title>
    <url>/2022/02/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>智能指针是为了解决动态内存分配时带来的内存泄漏以及多次释放同一块内存空间而提出的。C++11 中封装在了 &lt;memory&gt; 头文件中。</p>
<p>C++11 中智能指针包括以下三种：</p>
<ol>
<li><p>共享指针（shared_ptr）：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。通过 use_count() 查看资源的所有者的个数，可以通过 unique_ptr、weak_ptr 来构造，调用 release() 释放资源的所有权，计数减一，当计数减为 0 时，会自动释放内存空间，从而避免了内存泄漏。</p>
</li>
<li><p>独占指针（unique_ptr）：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。但可以进行移动构造和移动赋值构造（调用 move() 函数），即一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，可以通过该方法进行赋值。</p>
</li>
<li><p>弱指针（weak_ptr）：指向 share_ptr 指向的对象，能够解决由shared_ptr带来的循环引用问题。</p>
</li>
</ol>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>智能指针的实现原理： 计数原理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span> : </span><br><span class="line">    T *_ptr;</span><br><span class="line">    <span class="keyword">size_t</span> *_count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmartPtr</span>(T *ptr = <span class="literal">nullptr</span>) : _ptr(ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            _count = <span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _count = <span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">SmartPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        (*<span class="keyword">this</span>-&gt;_count)--;</span><br><span class="line">        <span class="keyword">if</span> (*<span class="keyword">this</span>-&gt;_count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SmartPtr</span>(<span class="keyword">const</span> SmartPtr &amp;ptr) <span class="comment">// 拷贝构造：计数 +1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_ptr = ptr._ptr;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_count = ptr._count;</span><br><span class="line">            (*<span class="keyword">this</span>-&gt;_count)++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SmartPtr &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPtr &amp;ptr) <span class="comment">// 赋值运算符重载 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_ptr == ptr._ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_ptr) <span class="comment">// 将当前的 ptr 指向的原来的空间的计数 -1</span></span><br><span class="line">        &#123;</span><br><span class="line">            (*<span class="keyword">this</span>-&gt;_count)--;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_count == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_ptr = ptr._ptr;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_count = ptr._count;</span><br><span class="line">        (*<span class="keyword">this</span>-&gt;_count)++; <span class="comment">// 此时 ptr 指向了新赋值的空间，该空间的计数 +1</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="keyword">this</span>-&gt;_ptr == <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="keyword">this</span>-&gt;_ptr == <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">use_count</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>-&gt;count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>智能指针可能出现的问题：循环引用</p>
<p>在如下例子中定义了两个类 Parent、Child，在两个类中分别定义另一个类的对象的共享指针，由于在程序结束后，两个指针相互指向对方的内存空间，导致内存无法释放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;Child&gt; ChildPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setChild</span><span class="params">(shared_ptr&lt;Child&gt; child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ChildPtr = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ChildPtr.<span class="built_in">use_count</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Parent</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;Parent&gt; ParentPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPartent</span><span class="params">(shared_ptr&lt;Parent&gt; parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ParentPtr = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ParentPtr.<span class="built_in">use_count</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Child</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    weak_ptr&lt;Parent&gt; wpp;</span><br><span class="line">    weak_ptr&lt;Child&gt; wpc;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">shared_ptr&lt;Parent&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Parent)</span></span>;</span><br><span class="line">        <span class="function">shared_ptr&lt;Child&gt; <span class="title">c</span><span class="params">(<span class="keyword">new</span> Child)</span></span>;</span><br><span class="line">        p-&gt;<span class="built_in">setChild</span>(c);</span><br><span class="line">        c-&gt;<span class="built_in">setPartent</span>(p);</span><br><span class="line">        wpp = p;</span><br><span class="line">        wpc = c;</span><br><span class="line">        cout &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">        cout &lt;&lt; c.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; wpp.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 1</span></span><br><span class="line">    cout &lt;&lt; wpc.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>循环引用的解决方法： weak_ptr</p>
<p>循环引用：该被调用的析构函数没有被调用，从而出现了内存泄漏。</p>
<ol>
<li><p>weak_ptr 对被 shared_ptr 管理的对象存在 非拥有性（弱）引用，在访问所引用的对象前必须先转化为 shared_ptr；</p>
</li>
<li><p>weak_ptr 用来打断 shared_ptr 所管理对象的循环引用问题，若这种环被孤立（没有指向环中的外部共享指针），shared_ptr 引用计数无法抵达 0，内存被泄露；令环中的指针之一为弱指针可以避免该情况；</p>
</li>
<li><p>weak_ptr 用来表达临时所有权的概念，当某个对象只有存在时才需要被访问，而且随时可能被他人删除，可以用 weak_ptr 跟踪该对象；需要获得所有权时将其转化为 shared_ptr，此时如果原来的 shared_ptr 被销毁，则该对象的生命期被延长至这个临时的 shared_ptr 同样被销毁。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//shared_ptr&lt;Child&gt; ChildPtr;</span></span><br><span class="line">    weak_ptr&lt;Child&gt; ChildPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setChild</span><span class="params">(shared_ptr&lt;Child&gt; child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ChildPtr = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//new shared_ptr</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ChildPtr.<span class="built_in">lock</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Parent</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;Parent&gt; ParentPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPartent</span><span class="params">(shared_ptr&lt;Parent&gt; parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ParentPtr = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ParentPtr.<span class="built_in">use_count</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Child</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    weak_ptr&lt;Parent&gt; wpp;</span><br><span class="line">    weak_ptr&lt;Child&gt; wpc;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">shared_ptr&lt;Parent&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Parent)</span></span>;</span><br><span class="line">        <span class="function">shared_ptr&lt;Child&gt; <span class="title">c</span><span class="params">(<span class="keyword">new</span> Child)</span></span>;</span><br><span class="line">        p-&gt;<span class="built_in">setChild</span>(c);</span><br><span class="line">        c-&gt;<span class="built_in">setPartent</span>(p);</span><br><span class="line">        wpp = p;</span><br><span class="line">        wpc = c;</span><br><span class="line">        cout &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">        cout &lt;&lt; c.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; wpp.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 0</span></span><br><span class="line">    cout &lt;&lt; wpc.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/2022/02/14/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>C++ 内存分区：栈、堆、全局/静态存储区、常量存储区、代码区。</p>
<ol>
<li><p>栈：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。</p>
</li>
<li><p>堆：动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。</p>
</li>
<li><p>全局区/静态存储区（.bss 段和 .data 段）：存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 语言中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。</p>
</li>
<li><p>常量存储区（.data 段）：存放的是常量，不允许修改，程序运行结束自动释放。</p>
</li>
<li><p>代码区（.text 段）：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。</p>
</li>
</ol>
<p>说明：</p>
<p>从操作系统的本身来讲，以上存储区在内存中的分布是如下形式(从低地址到高地址)：.text 段 –&gt; .data 段 –&gt; .bss 段 –&gt; 堆 –&gt; unused –&gt; 栈 –&gt; env</p>
<p>程序实例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明：C++ 中不再区分初始化和未初始化的全局变量、静态变量的存储区，如果非要区分下述程序标注在了括号中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_var = <span class="number">0</span>; <span class="comment">// g_var 在全局区（.data 段）</span></span><br><span class="line"><span class="keyword">char</span> *gp_var;  <span class="comment">// gp_var 在全局区（.bss 段）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var;                    <span class="comment">// var 在栈区</span></span><br><span class="line">    <span class="keyword">char</span> *p_var;                <span class="comment">// p_var 在栈区</span></span><br><span class="line">    <span class="keyword">char</span> arr[] = <span class="string">&quot;abc&quot;</span>;         <span class="comment">// arr 为数组变量，存储在栈区；&quot;abc&quot;为字符串常量，存储在常量区</span></span><br><span class="line">    <span class="keyword">char</span> *p_var1 = <span class="string">&quot;123456&quot;</span>;    <span class="comment">// p_var1 在栈区；&quot;123456&quot;为字符串常量，存储在常量区</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_var = <span class="number">0</span>;       <span class="comment">// s_var 为静态变量，存在静态存储区（.data 段）</span></span><br><span class="line">    p_var = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>); <span class="comment">// 分配得来的 10 个字节的区域在堆区</span></span><br><span class="line">    <span class="built_in">free</span>(p_var);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充总结：</p>
<p>在理解C/C++内存分区时，常会碰到如下术语：数据区，堆，栈，静态存储区，静态区，常量区，常变量区，全局区，字符串常量区，静态常量区，静态变量区，文字常量区，代码区等等，初学者被搞得云里雾里。在这里，尝试捋清楚以上分区的关系。</p>
<p>数据区包括：堆，栈，静态存储区。</p>
<p>静态存储区包括：常量区（静态常量区），全局区（全局变量区）和静态变量区（静态区）。</p>
<p>常量区包括：字符串常量区和常变量区。</p>
<p>代码区：存放程序编译后的二进制代码，不可寻址区。</p>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>编译</title>
    <url>/2022/02/14/%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>编译过程分为四个过程：预处理、编译、汇编、链接。</p>
<p>预处理：处理以 # 开头的指令；</p>
<p>编译：将源码 .cpp 文件翻译成 .s 汇编代码；</p>
<p>汇编：将汇编代码 .s 翻译成机器指令 .o 文件；</p>
<p>链接：汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现.cpp 文件中的函数引用了另一个.cpp 文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。</p>
<p><img src="https://s2.loli.net/2022/02/14/4LIRCm5AlKTZufH.png" alt="20220214141659"></p>
<p>链接分为两种：</p>
<p>静态链接：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</p>
<p>动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。</p>
<p>二者的优缺点：</p>
<p>静态链接：浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。</p>
<p>动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。</p>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0103</title>
    <url>/2022/01/03/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950103/</url>
    <content><![CDATA[<p>效果比较好的数据有：</p>
<table>
<thead>
<tr>
<th>数据编号</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>20211213_214603</td>
<td></td>
</tr>
<tr>
<td>20211213_210547</td>
<td></td>
</tr>
<tr>
<td>20211213_204805</td>
<td></td>
</tr>
<tr>
<td>20220103_195518</td>
<td>中间停了10s</td>
</tr>
<tr>
<td>20220103_200136</td>
<td>中间10s</td>
</tr>
<tr>
<td>20220103_201517</td>
<td>后半段人走开</td>
</tr>
<tr>
<td>20220103_202140</td>
<td>耳机架在桌子上，后半段走开了30-40s，再回来</td>
</tr>
<tr>
<td>20220103_204606</td>
<td>50多秒时人走开</td>
</tr>
<tr>
<td>20220103_205434</td>
<td>一直呼吸</td>
</tr>
<tr>
<td>20220103_205952</td>
<td>一直呼吸</td>
</tr>
<tr>
<td>20220103_210435</td>
<td>后面半段人走开</td>
</tr>
<tr>
<td>20220103_211403</td>
<td>中间人走开</td>
</tr>
<tr>
<td>20220103_212938</td>
<td>中间人走开</td>
</tr>
<tr>
<td>20220104_090548</td>
<td>一直呼吸</td>
</tr>
<tr>
<td>20220104_091117</td>
<td>中间人走开</td>
</tr>
</tbody></table>
<h2 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h2><ul>
<li>耳机戴在头上得到的结果要比放在桌子上的结果好。<br>分析：可能是由于人呼吸和心跳带动身体微小的动作会传递到头部，这样就会影响发射端，所以实验得到的波形可能不仅仅提取自反射信号，直达信号的变化很可能对实验结果有很大的影响。这也是该系统跟其它同类型的系统之间的一个区别，因为其它已有的测呼吸的工作大多是把发射端和接收端都放在人旁边，这样就只能从反射信号中提取信息，而我们的系统发射端是穿戴在任身体上的，呼吸和心跳的pattern会直接作用于发射端并通过直达信号反应出来。</li>
</ul>
<h2 id="后续的实验方向"><a href="#后续的实验方向" class="headerlink" title="后续的实验方向"></a>后续的实验方向</h2><ol>
<li><p>结合直达信号和反射信号共同用于波形提取。可以考虑把直达信号左右一部分的路径和其它路径设置不同的权重再放到一起做pca。</p>
</li>
<li><p>参数的调整。呼吸和心跳的snr阈值可能还需要进一步调整，用于识别出没有呼吸和心跳的场景。</p>
</li>
<li><p>路径选择的方法可能还需要调试，目前的结果是百分比法（前10%）效果比阈值法要好一些。</p>
</li>
<li><p>cir的长度和频率（现在是10）可能考虑一下是否需要调整。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>死锁</title>
    <url>/2021/12/26/%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就是死锁的。</p>
<h3 id="死锁的条件（四个同时满足）"><a href="#死锁的条件（四个同时满足）" class="headerlink" title="死锁的条件（四个同时满足）"></a>死锁的条件（四个同时满足）</h3><ol>
<li><p>互斥：每个资源要么已经分配给一个进程，要么就是可用的；</p>
</li>
<li><p>占有和等待：进程因请求资源而阻塞时，对已获得的资源保持不放；</p>
</li>
<li><p>不可抢占：已经分配的资源不能强制被抢占，只能进程自己释放；</p>
</li>
<li><p>环路等待：存在一种进程资源的循环等待链。</p>
</li>
</ol>
<h3 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h3><ol>
<li><p>死锁预防：破坏死锁的四个条件之一</p>
<p> 破环互斥条件：允许资源共享；</p>
<p> 破环占有和等待条件：一次性分配所有资源，只要缺少一个资源，其它资源也都不给他分配；</p>
<p> 破坏不可抢占：请求新资源得不到时，释放已经保持占有的资源，待以后重新申请；</p>
<p> 破坏环路等待：采用顺序资源分配法，给每个资源编号，进程申请资源的时候按照编号顺序申请，释放的时候则相反；</p>
</li>
<li><p>死锁避免：死锁避免事先预防策略，但是是采用资源动态分配的过程中，防止系统进入不安全状态，以避免死锁。</p>
<p> 预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前预先计算资源分配的安全性。若此次分配不会导致系统进入不安全的状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法。</p>
<p> 银行家算法：首先需要定义状态和安全状态的概念。系统的状态是当前给进程分配的资源情况。因此，状态包含两个向量Resource（系统中每种资源的总量）和Available（未分配给进程的每种资源的总量）及两个矩阵Claim（表示进程对资源的需求）和Allocation（表示当前分配给进程的资源）。安全状态是指至少有一个资源分配序列不会导致死锁。当进程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。如果是，同意这个请求；如果不是，阻塞该进程知道同意该请求后系统状态仍然是安全的。</p>
</li>
<li><p>死锁检测与解除：</p>
<p> 检测死锁：利用死锁原理化简资源分配图检测死锁的存在</p>
<p> 死锁解除：资源剥夺、撤销进程、进程回退</p>
<pre><code> 剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；

 撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。
</code></pre>
</li>
</ol>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针</title>
    <url>/2021/12/23/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>因为c++没有自动的内存回收机制，所以程序员每次在new一个对象的时候都需要手动delete，但是有的时候会忘记delete，或者因为程序分支等原因delete没有执行，就会使得对象没有释放而导致内存泄漏。</p>
<p>智能指针（shared_ptr）是一个类，存储了指向一个对象的指针，通过引用计数的方式记录有多少个智能指针对象共享同一个指针，它在指针没有被使用时会自动释放其内存。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>每次创建智能指针对象时，初始化其指针，引用计数设为1；</p>
<p>当智能指针对象成为另一个智能指针对象的副本时，执行拷贝构造函数，并将引用计数加1；</p>
<p>当执行赋值语句时，左操作数的引用计数减1，右操作数的引用计数加1；</p>
<p>当执行析构函数时，引用计数减1；</p>
<p>当引用计数为0时，释放内部指针指向的对象的空间。</p>
<h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>智能指针存在的一个经典问题就是循环引用问题，如下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">Node</span>(T data = <span class="built_in">T</span>()) :_data(data), <span class="built_in">Pnext</span>(<span class="literal">NULL</span>), <span class="built_in">Ppre</span>(<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Node</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Call ~Node()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	shared_ptr&lt;Node&gt; Pnext;</span><br><span class="line">	shared_ptr&lt;Node&gt; Ppre;</span><br><span class="line">	T _data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testShared_Ptr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	shared_ptr&lt;Node&lt;<span class="keyword">int</span>&gt;&gt;<span class="built_in">sp1</span>(<span class="keyword">new</span> Node&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>));</span><br><span class="line">	shared_ptr&lt;Node&lt;<span class="keyword">int</span>&gt;&gt;<span class="built_in">sp2</span>(<span class="keyword">new</span> Node&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">	cout &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;<span class="comment">//1</span></span><br><span class="line">	cout &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; endl;<span class="comment">//1</span></span><br><span class="line">	sp1-&gt;Pnext = sp2;</span><br><span class="line">	sp2-&gt;Ppre = sp1;</span><br><span class="line">	cout &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;<span class="comment">//2</span></span><br><span class="line">	cout &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; endl;<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Node&lt;int&gt; *a = new Node&lt;int&gt;(3);</span></span><br><span class="line"><span class="comment">    delete a;</span></span><br><span class="line"><span class="comment">    shared_ptr&lt;Node&lt;int&gt;&gt; c(new Node&lt;int&gt;(4));*/</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">testShared_Ptr</span>();                                                                                                                            </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;testShared_pte()函数运行结束&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数testShared_Ptr执行完之后，会先释放sp2，所以sp2的引用计数减1变为1，然后释放sp1的内存，sp1的引用计数也减1变为1。因为sp1中有对sp2的指针，sp2中也有sp1的指针，所以导致二者的引用计数都没有办法变为0，于是导致二者的内存空间都不会释放。</p>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录1221</title>
    <url>/2021/12/21/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%951221/</url>
    <content><![CDATA[<p>用CIR虚部做PCA效果更好</p>
<p>呼吸：</p>
<p><img src="https://s2.loli.net/2021/12/21/W5AoQdFGH94CTsZ.png" alt="20211221145747"></p>
<p>心跳：</p>
<p><img src="https://s2.loli.net/2021/12/21/Tp1HgViDaFe5WlS.png" alt="20211221150024"></p>
<p>实部和虚部分别独立做PCA再将结果相减：（效果又好了一点）</p>
<p><img src="https://s2.loli.net/2021/12/21/51CL9mc6FfYwMXz.png" alt="20211221190046"></p>
<p>数据编号：20211213_214603</p>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>继承方式</title>
    <url>/2021/12/20/%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>不同的继承方式会影响基类成员在派生类中的访问权限。</p>
<ol>
<li>public继承方式</li>
</ol>
<ul>
<li>基类中所有 public 成员在派生类中为 public 属性；</li>
<li>基类中所有 protected 成员在派生类中为 protected 属性；</li>
<li>基类中所有 private 成员在派生类中不能使用。</li>
</ul>
<ol start="2">
<li>protected继承方式</li>
</ol>
<ul>
<li>基类中的所有 public 成员在派生类中为 protected 属性；</li>
<li>基类中的所有 protected 成员在派生类中为 protected 属性；</li>
<li>基类中的所有 private 成员在派生类中不能使用。</li>
</ul>
<ol start="3">
<li>private继承方式</li>
</ol>
<ul>
<li>基类中的所有 public 成员在派生类中均为 private 属性；</li>
<li>基类中的所有 protected 成员在派生类中均为 private 属性；</li>
<li>基类中的所有 private 成员在派生类中不能使用。</li>
</ul>
<p>默认是私有继承</p>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>tcp拥塞控制</title>
    <url>/2021/12/18/tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><ol>
<li><p>慢开始</p>
<p>在发生拥塞（触发超时重传）时执行慢开始算法，发生拥塞时慢开始门限ssthresh减为原来一半。</p>
<p>慢开始时把拥塞窗口cwnd设为1，每收到一个ack时cwnd+1，所以每经过一轮RTT后cwnd会乘2。</p>
</li>
<li><p>拥塞避免</p>
<p>当拥塞窗口cwnd大于慢开始门限sstresh之后，cwnd每经过一轮RTT后自增1.</p>
</li>
<li><p>快重传</p>
<p>有时网络没有拥塞但是个别报文也会丢失，这时候如果触发慢开始就会导致网络利用率下降，所以有了快重传算法。</p>
<p>快重传就是在发射端连续接收到三个相同的ack时立刻对丢失的报文进行重传而不管重传计时器是否超时，之后进行快恢复而不是慢开始。</p>
</li>
<li><p>快恢复</p>
<p>快恢复就是把拥塞窗口cwnd和慢开始门限都设置为触发快重传时cwnd的一半，然后执行拥塞避免。</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/18/qukW3yYiwGLh2UJ.png" alt="20211218115702"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>拥塞窗口小于慢开始门限时，执行慢开始算法，拥塞窗口指数增长；拥塞窗口大于慢开始门限时，执行拥塞避免算法，拥塞窗口线性增长。</p>
<p>在没有发生拥塞时，拥塞窗口增大；在可能发生拥塞时，拥塞窗口减小。</p>
<p>判断网络是否发生拥塞的依据为是否触发超时重传。</p>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>网页打开所经历的过程</title>
    <url>/2021/12/15/%E7%BD%91%E9%A1%B5%E6%89%93%E5%BC%80%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="1-DNS解析"><a href="#1-DNS解析" class="headerlink" title="1.DNS解析"></a>1.DNS解析</h2><h3 id="输入网址后，浏览器会先在自己的缓存中查找网址对应的ip"><a href="#输入网址后，浏览器会先在自己的缓存中查找网址对应的ip" class="headerlink" title="输入网址后，浏览器会先在自己的缓存中查找网址对应的ip"></a>输入网址后，浏览器会先在自己的缓存中查找网址对应的ip</h3><h3 id="如果没找到，会从计算机缓存中查找（在host中手动绑定的网址和ip会记录在计算机缓存中）"><a href="#如果没找到，会从计算机缓存中查找（在host中手动绑定的网址和ip会记录在计算机缓存中）" class="headerlink" title="如果没找到，会从计算机缓存中查找（在host中手动绑定的网址和ip会记录在计算机缓存中）"></a>如果没找到，会从计算机缓存中查找（在host中手动绑定的网址和ip会记录在计算机缓存中）</h3><h3 id="如果还没找到，会向路由器缓存中查找"><a href="#如果还没找到，会向路由器缓存中查找" class="headerlink" title="如果还没找到，会向路由器缓存中查找"></a>如果还没找到，会向路由器缓存中查找</h3><h3 id="如果还没有，就向DNS服务器查找"><a href="#如果还没有，就向DNS服务器查找" class="headerlink" title="如果还没有，就向DNS服务器查找"></a>如果还没有，就向DNS服务器查找</h3><h3 id="如果还找不到，会向根域名服务器查找，根域名服务器会根据网址递归地一层一层向下属域名服务器查找，最后将ip返回给客户端"><a href="#如果还找不到，会向根域名服务器查找，根域名服务器会根据网址递归地一层一层向下属域名服务器查找，最后将ip返回给客户端" class="headerlink" title="如果还找不到，会向根域名服务器查找，根域名服务器会根据网址递归地一层一层向下属域名服务器查找，最后将ip返回给客户端"></a>如果还找不到，会向根域名服务器查找，根域名服务器会根据网址递归地一层一层向下属域名服务器查找，最后将ip返回给客户端</h3><h3 id="客户端拿到ip后更新自己的缓存并与服务器建立连接"><a href="#客户端拿到ip后更新自己的缓存并与服务器建立连接" class="headerlink" title="客户端拿到ip后更新自己的缓存并与服务器建立连接"></a>客户端拿到ip后更新自己的缓存并与服务器建立连接</h3><h2 id="2-网络通信"><a href="#2-网络通信" class="headerlink" title="2.网络通信"></a>2.网络通信</h2><h3 id="TCP三次握手建立链接"><a href="#TCP三次握手建立链接" class="headerlink" title="TCP三次握手建立链接"></a>TCP三次握手建立链接</h3><p><img src="https://s2.loli.net/2021/12/15/82Kq4HfkiRjMYGP.png" alt="20211215213744"></p>
<h3 id="四次挥手释放链接"><a href="#四次挥手释放链接" class="headerlink" title="四次挥手释放链接"></a>四次挥手释放链接</h3><p><img src="https://s2.loli.net/2021/12/15/ehx1bui5gIOnC7L.png" alt="20211215213754"></p>
<p>为什么“握手”是三次，“挥手”却要四次？</p>
<p>TCP建立连接时之所以只需要”三次握手”，是因为在第二次”握手”过程中，服务器端发送给客户端的TCP报文是以SYN与ACK作为标志位的。SYN是请求连接标志，表示服务器端同意建立连接；ACK是确认报文，表示告诉客户端，服务器端收到了它的请求报文。</p>
<p>即SYN建立连接报文与ACK确认接收报文是在同一次”握手”当中传输的，所以”三次握手”不多也不少，正好让双方明确彼此信息互通。</p>
<p>TCP释放连接时之所以需要“四次挥手”,是因为FIN释放连接报文与ACK确认接收报文是分别由第二次和第三次”握手”传输的。为何建立连接时一起传输，释放连接时却要分开传输？</p>
<p>建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。</p>
<h2 id="3-页面渲染"><a href="#3-页面渲染" class="headerlink" title="3.页面渲染"></a>3.页面渲染</h2>]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录1213</title>
    <url>/2021/12/13/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%951213/</url>
    <content><![CDATA[<p>数据编号：20211213_205317</p>
<p>第4个特征值对应的呼吸好像比较靠谱</p>
<p>每次呼吸的峰值都是负数，应该是因为原始数据的dcir采用的是后一帧减前一帧，而呼吸时前半段是胸膛隆起，对应测得的反射径的距离是逐渐减小，所以是负数。</p>
<p><img src="https://s2.loli.net/2021/12/13/iSVNnPo7pfmL4gQ.png" alt="20211213210148"></p>
<p>用原始cir进行pca</p>
<p><img src="https://s2.loli.net/2021/12/13/y6OjuASfVe91lnk.png" alt="20211213212723"></p>
<p>对cir进行低通滤波</p>
<p><img src="https://s2.loli.net/2021/12/13/yS3A9fqotuJkc64.png" alt="20211213212756"></p>
<p>用差分的dcir进行pca</p>
<p>第四个特征值对应的结果出奇的好</p>
<p><img src="https://s2.loli.net/2021/12/13/mufgJYEo4SbdzPv.png" alt="20211213213401"></p>
<p>对dcir进行低通滤波</p>
<p>效果变差了</p>
<p><img src="https://s2.loli.net/2021/12/13/ixVj64o12wpTclm.png" alt="20211213213732"></p>
<p>数据编号：20211213_214603</p>
<p><img src="https://s2.loli.net/2021/12/13/KkeWJOQdwqzDoYm.png" alt="20211213215710"></p>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>索引</title>
    <url>/2021/12/04/%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>索引是对数据库表中一列或多列的值进行处理后的一种结构，使用索引可快速访问数据库表中的特定信息。</p>
<h2 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h2><p>说到Hash，老铁们很容易联想到HashMap，没错，Hash索引的结构和HashMap相类似，键值 key 通过 Hash 映射找到桶 bucket。在这里桶（bucket）指的是一个能存储一条或多条记录的存储单位。一个桶的结构包含了一个内存指针数组，桶中的每行数据都会指向下一行，形成链表结构，当遇到 Hash 冲突时，会在桶中进行键值的查找。</p>
<p>InnoDB中采用除法散列函数(取余法)，冲突机制采用链接法。</p>
<h2 id="Hash索引和B-tree索引查询效率"><a href="#Hash索引和B-tree索引查询效率" class="headerlink" title="Hash索引和B+tree索引查询效率"></a>Hash索引和B+tree索引查询效率</h2><p>采用 Hash 进行检索效率非常高，基本上一次检索就可以找到数据，而 B+ 树需要自顶向下依次查找，多次访问节点才能找到数据，中间需要多次 I/O 操作，理论上来说 Hash 比 B+ tree更快。下图是引用网上的Hash索引图片和 B+tree 索引图片，便于直观的理解2种索引结构。</p>
<h3 id="Hash索引-1"><a href="#Hash索引-1" class="headerlink" title="Hash索引"></a>Hash索引</h3><p><img src="https://s2.loli.net/2021/12/04/BOnpZRJCkog1e4U.png" alt="20211204161752"></p>
<h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p><img src="https://s2.loli.net/2021/12/04/LPS6OpWXoGTYDtB.png" alt="20211204161803"></p>
<h2 id="Hash索引和B-tree索引的区别"><a href="#Hash索引和B-tree索引的区别" class="headerlink" title="Hash索引和B+tree索引的区别"></a>Hash索引和B+tree索引的区别</h2><ol>
<li><p>在查询速度上，如果是等值查询，那么Hash索引明显有绝对优势，因为只需要经过一次 Hash 算法即可找到相应的键值，复杂度为O(1)；当然了，这个前提是键值都是唯一的。如果键值不是唯一(或存在Hash冲突)，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据，这时候复杂度会变成O(n)，降低了Hash索引的查找效率。所以，Hash 索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等（当然B+tree索引也不适合这种离散型低的字段上）；</p>
</li>
<li><p>Hash 索引是无序的，如果是范围查询检索，这时候 Hash 索引就无法起到作用，即使原先是有序的键值，经过 Hash 算法后，也会变成不连续的了。因此:</p>
<ol>
<li><p>Hash 索引只支持等值比较查询、无法索成范围查询检索，B+tree索引的叶子节点形成有序链表，便于范围查询。</p>
</li>
<li><p>Hash 索引无法做 like ‘xxx%’ 这样的部分模糊查询，因为需要对 完整 key 做 Hash 计算，定位bucket。而 B+tree 索引具有最左前缀匹配，可以进行部分模糊查询。</p>
</li>
<li><p>Hash索引中存放的是经过Hash计算之后的Hash值，而且Hash值的大小关系并不一定和Hash运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算。B+tree 索引的叶子节点形成有序链表，可用于排序。</p>
</li>
</ol>
</li>
<li><p>Hash 索引不支持多列联合索引，对于联合索引来说，Hash 索引在计算 Hash 值的时候是将索引键合并后再一起计算 Hash 值，不会针对每个索引单独计算 Hash 值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用；</p>
</li>
<li><p>因为存在哈希碰撞问题，在有大量重复键值情况下，哈希索引的效率极低。B+tree 所有查询都要找到叶子节点，性能稳定；</p>
</li>
</ol>
<h2 id="场景区分"><a href="#场景区分" class="headerlink" title="场景区分"></a>场景区分</h2><ol>
<li><p>大多数场景下，都会有组合查询，范围查询、排序、分组、模糊查询等查询特征，Hash 索引无法满足要求，建议数据库使用B+树索引。</p>
</li>
<li><p>在离散型高，数据基数大，且等值查询时候，Hash索引有优势。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>b树和b+树</title>
    <url>/2021/12/04/b%E6%A0%91%E5%92%8Cb+%E6%A0%91/</url>
    <content><![CDATA[<h2 id="b树"><a href="#b树" class="headerlink" title="b树"></a>b树</h2><p>b树就是平衡M叉树。跟平衡二叉树类似，avl的非叶子节点只有一个关键字，b树的非叶子节点有M-1个关键字。M-1个关键字将数据划分为M段，每个儿子节点对应一段。b树的叶子结点和非叶子节点都存放数据。</p>
<p><img src="https://s2.loli.net/2021/12/04/5de4ZTs6hIn9Rbw.png" alt="20211204160835"></p>
<p>一个M阶的b树具有如下几个特征：</p>
<ul>
<li>定义任意非叶子结点最多只有M个儿子，且M&gt;2；</li>
<li>根结点的儿子数为[2, M]；</li>
<li>除根结点以外的非叶子结点的儿子数为[M/2, M]，向上取整；</li>
<li>非叶子结点的关键字个数=儿子数-1；</li>
<li>所有叶子结点位于同一层；</li>
<li>k个关键字把节点拆成k+1段，分别指向k+1个儿子，同时满足查找树的大小关系。</li>
</ul>
<p>有关b树的一些特性，注意与后面的b+树区分：</p>
<ul>
<li>关键字集合分布在整颗树中；</li>
<li>任何一个关键字出现且只出现在一个结点中；</li>
<li>搜索有可能在非叶子结点结束；</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找；</li>
</ul>
<h2 id="b-树"><a href="#b-树" class="headerlink" title="b+树"></a>b+树</h2><p>b+树是b树的变体，区别是b+树非叶子节点有M个关键字，并且不在非叶子结点存储数据，同时b+树的叶子结点之间也有指针相连。</p>
<p><img src="https://s2.loli.net/2021/12/04/YuMm2KXtR9BWk63.png" alt="20211204160733"></p>
<p>M阶的b+树的特征：</p>
<ul>
<li>有M棵子树的非叶子结点中含有M个关键字（b树是M-1个），这些关键字不保存数据，只用来索引，所有数据都保存在叶子节点（b树是每个关键字都保存数据）。</li>
<li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li>
<li>所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</li>
<li>通常在b+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。</li>
<li>同一个数字会在不同节点中重复出现，根节点的最大元素就是b+树的最大元素。</li>
</ul>
<p>b+树相比于b树的查询优势：</p>
<ul>
<li>b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；</li>
<li>b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；</li>
<li>对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历;</li>
</ul>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>B+树</title>
    <url>/2021/12/04/B+%E6%A0%91/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2021/12/04/AwbHXzlkDKIBPuW.png" alt="20211204154031"></p>
<p>浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。</p>
<p>真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p>
<h3 id="b-树的查找过程"><a href="#b-树的查找过程" class="headerlink" title="b+树的查找过程"></a>b+树的查找过程</h3><p>如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。</p>
<p>真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p>
<p>从IO的角度来说B+树的复杂度是O(log<sub>m</sub>N)</p>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>SSL</title>
    <url>/2021/12/04/SSL/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2021/12/04/vDsWVg24TJExnti.png" alt="20211204150221"></p>
<p>http是超文本传输协议，服务器和浏览器之间的数据传输使用的是明文传输，所以很不安全。</p>
<p>https就是在http的基础上增加安全套接字层SSL(sercue socket layer)，使用SSL对服务器和浏览器之间的数据传输进行加密。</p>
<p>第一阶段：建立安全能力</p>
<p>客户端-client_hello：</p>
<ul>
<li>客户端可以支持的SSL最高版本号;</li>
<li>客户端生成的32字节的随机数;</li>
<li>会话标识符ID;</li>
<li>客户端可以支持的密码套件列表;</li>
<li>客户端可以支持的压缩方法列表。</li>
</ul>
<p>服务端-server_hello：</p>
<ul>
<li>SSL版本号，取收到的客户端SSL版本和服务端支持的最高版本中的较低者;</li>
<li>服务端生成的32字节的随机数;</li>
<li>会话标识符ID;</li>
<li>从收到的客户端密码套件列表中选择一个密码套件(包含密钥交换算法、对称加密算法、摘要算法);</li>
<li>从收到的客户端压缩方法列表中选择一种压缩方法。</li>
</ul>
<p>第二阶段：服务端验证和密钥交换</p>
<p>服务端-certificate：</p>
<ul>
<li>含有公钥信息的服务端数字证书或到CA的完整证书链。</li>
</ul>
<p>服务端-server_key_exchange：</p>
<ul>
<li>可选，根据密钥协商算法而定，如果传送给客户端的服务端证书数据不足以按照第一阶段选定的密钥交换算法协商密钥，该步骤不足密钥协商元素。</li>
</ul>
<p>服务端-certificate_request：</p>
<ul>
<li>可选，请求验证客户端证书信息，单向数据认证(只认证服务端)无此步骤。</li>
</ul>
<p>服务端-server_hello_done：</p>
<ul>
<li>通知客户端版本号和加密套件协商结束。</li>
</ul>
<p>第三阶段：客户端验证和密钥交换</p>
<p>客户端-certificate：</p>
<ul>
<li>可选，客户端数字证书，双向数据认证中服务端要求验证客户端身份合法性。</li>
</ul>
<p>客户端-client_key_exchange：</p>
<ul>
<li>客户端交换密钥，视密钥交换算法而定，密钥协商参数或pre-master key(服务端公钥加密)。</li>
</ul>
<p>客户端-certificate_verify：</p>
<ul>
<li>可选，客户端将已交互的握手消息、会话密钥的摘要值用客户端私钥加密发送给服务端。</li>
</ul>
<p>第四阶段：完成</p>
<p>客户端-change_cipher_spec：</p>
<ul>
<li>改变密码格式信息，告诉服务端之后的报文消息用会话密钥加密。</li>
</ul>
<p>客户端-finished：</p>
<ul>
<li>向服务端宣布握手协议完成。</li>
</ul>
<p>服务端-change_cipher_spec：</p>
<ul>
<li>改变密码格式信息，告诉客户端之后的报文消息用会话密钥加密。</li>
</ul>
<p>服务端-finished：</p>
<ul>
<li>向客户端宣布握手协议完成。</li>
</ul>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>优先队列</title>
    <url>/2021/12/04/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>C++ STL里的优先队列priority_queue底层时用堆实现的。</p>
<p>使用时简单的小顶堆/大顶堆可以如下定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;  <span class="comment">//小顶堆</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt; q;  <span class="comment">//大顶堆</span></span><br></pre></td></tr></table></figure>

<p>但是greater和less只适用于简单的元素类型，对于复杂元素（比如自定义的结构体）需要重载运算符&lt;。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> dis;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp;a) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.dis&lt;dis; <span class="comment">// 小顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路算法总结</title>
    <url>/2021/12/03/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>算法变革：BFS-&gt;Dijkstra-&gt;A*</p>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>1162. 地图分析</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">    <span class="keyword">int</span> nx, ny, nz;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        z = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        vis[z] = <span class="literal">true</span>;</span><br><span class="line">        x = z/n;</span><br><span class="line">        y = z%n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            nx = x+dir[i][<span class="number">0</span>];</span><br><span class="line">            ny = y+dir[i][<span class="number">1</span>];</span><br><span class="line">            nz = nx*n+ny;</span><br><span class="line">            <span class="keyword">if</span>(nx&gt;=<span class="number">0</span>&amp;&amp;nx&lt;n&amp;&amp;ny&gt;=<span class="number">0</span>&amp;&amp;ny&lt;n&amp;&amp;!mp[nx][ny]&amp;&amp;!vis[nz]&amp;&amp;dis[nz]&gt;dis[z]+<span class="number">1</span>)&#123;</span><br><span class="line">                dis[nz] = dis[z] + <span class="number">1</span>;</span><br><span class="line">                que.<span class="built_in">push</span>(nz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = dis[z];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BFS只能用来解决无权图的最短路问题。</p>
<h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><p>743. 网络延迟时间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0x3f3f3f3f</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j]&amp;&amp;dis[j]&lt;dis[mx])&#123;</span><br><span class="line">                mx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mx==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        vis[mx] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j]&amp;&amp;dis[j]&gt;dis[mx]+mp[mx][j])&#123;</span><br><span class="line">                dis[j] = dis[mx] + mp[mx][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dis[mx]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dijkstra可以解决带权图的最短路问题，但是普通版Dijkstra的时间复杂度是O(N^2)的，可以使用堆优化来降低复杂度。</p>
<h3 id="堆优化Dijkstra"><a href="#堆优化Dijkstra" class="headerlink" title="堆优化Dijkstra"></a>堆优化Dijkstra</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> dis;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp;a) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.dis&lt;dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;node&gt; que;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[j]==<span class="number">0</span>)&#123;</span><br><span class="line">            que.<span class="built_in">push</span>(node&#123;j,<span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node tmp = que.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">int</span> u = tmp.num;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j]&amp;&amp;dis[j]&gt;dis[u]+mp[u][j])&#123;</span><br><span class="line">                dis[j] = dis[u] + mp[u][j];</span><br><span class="line">                que.<span class="built_in">push</span>(node&#123;j,dis[j]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dis[u]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆优化就是把每次寻找优先级最高的节点的操作用一个小顶堆代替，复杂度为O(nlogn)。</p>
<h2 id="BestFirst-最佳优先搜索"><a href="#BestFirst-最佳优先搜索" class="headerlink" title="BestFirst(最佳优先搜索)"></a>BestFirst(最佳优先搜索)</h2><p>BestFirst就是把未搜索节点的优先级定义为该节点与目标节点之间的<strong>估计距离</strong>，如果这个估计距离刚好是真实距离，则BestFirst可以很快搜索到目标节点，但是大多数情况下估计距离时不准确的。这个估计距离是非常启发式的，比如曼哈顿距离等。如果估计距离设定的不准确，那么很可能得到的最短路是错误的。</p>
<h2 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h2><p>A*结合了Dijkstra和BestFirst，关键的区别也是对未搜索节点的优先级定义。A*将优先级定义为：f(n) = g(n) + h(n)。其中g(n)是该节点到其实节点的距离，h(n)是一个启发式函数表示该节点到目标节点之间的估计距离。</p>
<p>在极端情况下，如果h(n)=0则A*退化为Dijkstra，如果g(n)=0则A*退化为BestFirst。</p>
<p>如果h(n)小于该节点到目标节点的实际距离，则A*一定能找到最短路，但是h(n)越小，搜索的节点就越多，导致算法就越慢；</p>
<p>如果h(n)刚好等于该节点到目标节点的实际距离，则A*会以很快的速度找到最短路，但是在现实中很难找到这样的h(n);</p>
<p>如果h(n)大于该节点到目标节点的实际距离，则A*不一定能找到最短路，不过此时算法的速度会很快。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>insert和erase</title>
    <url>/2021/12/03/insert%E5%92%8Cerase/</url>
    <content><![CDATA[<p>string和vector都有insert和erase函数，但是参数有区别。</p>
<table>
<thead>
<tr>
<th>容器</th>
<th>insert</th>
<th>erase</th>
<th>*note</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>s.insert(i, s)</td>
<td>s.erase(i, n)</td>
<td>string可以用迭代器也可以直接用下标，习惯直接用下标</td>
</tr>
<tr>
<td>vector</td>
<td>a.insert(a.begin()+i, val)</td>
<td>a.erase(a.begin()+i)</td>
<td>vector只能用迭代器</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>区间dp</title>
    <url>/2021/12/01/%E5%8C%BA%E9%97%B4dp/</url>
    <content><![CDATA[<h2 id="1-先枚举区间长度"><a href="#1-先枚举区间长度" class="headerlink" title="1.先枚举区间长度"></a>1.先枚举区间长度</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">3</span>;len&lt;=n;len++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+len<span class="number">-1</span>&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = i+len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;=j<span class="number">-1</span>;k++)&#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], a[k]*a[i]*a[j]+dp[i][k]+dp[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种比较好理解。</p>
<h2 id="2-先枚举区间边界"><a href="#2-先枚举区间边界" class="headerlink" title="2.先枚举区间边界"></a>2.先枚举区间边界</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n<span class="number">-1</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;=j<span class="number">-1</span>;k++)&#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], a[k]*a[i]*a[j]+dp[i][k]+dp[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式在枚举左边界的时候需要逆序枚举，因为区间dp要保证所有小区间都被计算过了才能计算大区间，如果i正向枚举的话，会导致dp[k][j]没有被计算过，因为k&gt;i，而反向枚举i即可保证所有的dp[k][j]都被计算过。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>基数排序</title>
    <url>/2021/12/01/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>一个基于非比较的排序算法，只能应用于整数排序，复杂度为O(dn)，d是整数最大的长度，即可以在线性时间和线性空间复杂度内完成排序，快于一切基于比较的排序算法，比如快排、归并排序等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//sort(nums.begin(),nums.end());</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">        <span class="comment">// 找到最大的整数，决定排序迭代的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            mx = max(mx, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(mx&gt;=x)&#123;</span><br><span class="line">            <span class="comment">// 计数器</span></span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">            <span class="comment">// 对十进制的每一位进行计数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> d = (nums[i]/x)%<span class="number">10</span>;</span><br><span class="line">                cnt[d] ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把计数器转换为索引</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                cnt[i] += cnt[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 逆序遍历，对数组进行重新排序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="keyword">int</span> d = (nums[i]/x)%<span class="number">10</span>;</span><br><span class="line">                tmp[cnt[d]<span class="number">-1</span>] = nums[i];</span><br><span class="line">                cnt[d] --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新数组</span></span><br><span class="line">            <span class="comment">//copy(tmp.begin(), tmp.end(), nums.begin());</span></span><br><span class="line">            nums.swap(tmp);</span><br><span class="line">            </span><br><span class="line">            x *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            ans = max(ans, nums[i]-nums[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2021/12/09/IaWo8EmNZrgLSdn.png" alt="20211209124114"></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>new和malloc</title>
    <url>/2021/11/30/new%E5%92%8Cmalloc/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>malloc</th>
<th>new</th>
</tr>
</thead>
<tbody><tr>
<td>从<strong>堆</strong>上动态分配内存</td>
<td>从<strong>自由存储区</strong>动态分配内存</td>
</tr>
<tr>
<td>返回值是void*，需要强制转换</td>
<td>自动返回对象类型的指针</td>
</tr>
<tr>
<td>需要制定内存大小</td>
<td>不需要制定内存大小</td>
</tr>
<tr>
<td>分配失败返回NULL</td>
<td>分配失败抛出bac_alloc异常</td>
</tr>
<tr>
<td>内存不够不能重新分配</td>
<td>可以重新分配</td>
</tr>
<tr>
<td>不能调用构造函数和析构函数</td>
<td>可以调用构造函数和析构函数</td>
</tr>
<tr>
<td>不能初始化数组元素对象</td>
<td>可以初始化数组元素对象？</td>
</tr>
</tbody></table>
<p><strong>自由存储区</strong>是c++基于new操作符的一个抽象概念，其可以是堆也可以是静态存储区，主要取决于operator new的实现。</p>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>const</title>
    <url>/2021/11/30/const/</url>
    <content><![CDATA[<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>const是只读类型的变量，值不能修改，只能在定义的时候赋值。</p>
<p>形式为const int a = 1;</p>
<h2 id="常量指针和指针常量"><a href="#常量指针和指针常量" class="headerlink" title="常量指针和指针常量"></a>常量指针和指针常量</h2><p><strong>常量指针</strong>又叫<strong>底层const</strong>，形式为const int *p = &a;</p>
<p>特点：不能使用该指针修改指向的值，但是可以修改指针指向的地址。</p>
<p>即，初始化后不可以*p=2，但是可以p=&b;</p>
<p><strong>指针常量</strong>又叫<strong>顶层const</strong>，形式为int* const p = &a;</p>
<p>特点：能使用该指针修改指向的值，但是不可以修改指针指向的地址。</p>
<p>即，初始化后可以*p=2，但是不能p=&b;</p>
<p>还有一种叫做<strong>常指针常量</strong>的，形式为const int* const a = &b;</p>
<p>是常量指针和指针常量的综合，既不可以修改指针指向的地址也不可以修改指针指向的值。</p>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>论文</title>
    <url>/2021/10/19/%E8%AE%BA%E6%96%87/</url>
    <content><![CDATA[<p>\section{INTRODUCTION}</p>
<p>\subsection{background}</p>
<p>\subsection{application}</p>
<p>\subsection{related work}</p>
<p>\subsection{propose}</p>
<p>\subsection{challenge}</p>
<p>\subsection{techniques}</p>
<p>\subsection{contributions}</p>
<p>\subsection{paper organization}</p>
<p>\section{BACKGROUND}</p>
<p>\section{RELATED WORK}</p>
<p>\section{SYSTEM DESIGN}</p>
<p>\subsection{System Overview}</p>
<p>headphone positioning -&gt; Head movement recognition -&gt; Head posture tracking</p>
<p>\subsection{headphone positioning}</p>
]]></content>
  </entry>
  <entry>
    <title>实验记录1015</title>
    <url>/2021/10/15/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%951015/</url>
    <content><![CDATA[<p>发射端距离身体十几厘米：20211014_103041</p>
<p><img src="https://i.loli.net/2021/10/15/CYOQKIJ91GlMoNX.png" alt="20211015110858"></p>
<p>这个数据还不错：20211015_123426<br><img src="https://i.loli.net/2021/10/15/8V6OMJUa2WSP9dI.png" alt="20211015123542"></p>
<p>20211015_123946<br><img src="https://i.loli.net/2021/10/15/UnR4d2KDhAVlqYi.png" alt="20211015124113"></p>
<p>发射端放到耳机上就不太好了：20211015_130101<br><img src="https://i.loli.net/2021/10/15/iHRTZQvMa7yIGpq.png" alt="20211015130229"></p>
<p>发射端在耳机上，20211015_130834，SNR阈值设置为0.9效果还不错<br><img src="https://i.loli.net/2021/10/15/V4fqxD51rvb6dgU.png" alt="20211015131249"></p>
<h2 id="六个接收端"><a href="#六个接收端" class="headerlink" title="六个接收端"></a>六个接收端</h2><p>数据编号：20211015_184816 降维后的第三个特征向量还可以</p>
<p><img src="https://i.loli.net/2021/10/15/BhZlSYc5goHdTj4.png" alt="20211015185038"></p>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录1012</title>
    <url>/2021/10/12/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%951012/</url>
    <content><![CDATA[<p>先对CIR做滑动平均滤波，然后在做PCA降维，得到的呼吸结果。</p>
<p><img src="https://i.loli.net/2021/10/12/vTUS6tgoYzJaHhi.png" alt="20211012150346"></p>
<p>数据编号：20211010_140604</p>
<p>发射端放在肚子附近：20211012_170451</p>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录1008</title>
    <url>/2021/10/08/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%951008/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/10/08/jt2qzDFK9uLiTNU.png" alt="20211008123140"><br>（左边是cir右边是dcir）</p>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>讨论0924</title>
    <url>/2021/09/23/%E8%AE%A8%E8%AE%BA0924/</url>
    <content><![CDATA[<h2 id="头部追踪系统"><a href="#头部追踪系统" class="headerlink" title="头部追踪系统"></a>头部追踪系统</h2><h3 id="系统组成"><a href="#系统组成" class="headerlink" title="系统组成"></a>系统组成</h3><ol>
<li><p>耳机定位</p>
<p>在环境中部署若干个接收端，在左右耳机各部署一个发射端。两发射端发射不同的zc超声信号，接收端接收信号。参考GPS卫星定位的思想，每次都选择信号质量最好的三个接收端来计算与耳机的距离，然后根据三个距离用牛顿迭代解方程计算出耳机的位置（自己手写了牛顿迭代的代码解决了matlab里solve函数计算太慢的问题）。</p>
<p>存在的问题：</p>
<ol>
<li>计算距离时用相位好像比不用相位效果更差。因为不用相位的精度是声速除以采样率（96k）精度为3.5mm左右，但是用相位要把距离先对波长取整，而波长是8.5mm左右，虽然可以用相位进行补偿，但是实验看起来补偿效果不是太好，用相位的测得的距离波动更大一些。<br><img src="https://i.loli.net/2021/09/24/c4IuQTwvkZKHYxq.png" alt="20210924124649"></li>
<li>计算位置过程中因为每次都要选择三个信号最好的接收端，导致一旦接收端切换位置就可能会出现比较大的偏移。</li>
</ol>
</li>
<li><p>头部动作识别</p>
<p>把头部的动作进行分类（目前分成了六类，分别是：前后移动，左右移动，上下移动，旋转，俯仰，倾斜），然后利用耳机的位置数据来判断头部正在做哪个动作。</p>
<p>采用LSTM作为分类模型，用左右耳机的轨迹完成头部动作分类。每秒对耳机定位10次，把两耳机2s的轨迹作为训练数据，因为每个耳机的位置是3维，所以构造特征维度为6长度为20的数据输入LSTM训练，六分类的平均准确率达到了97%以上。</p>
<p>构造了一个数据集，六类动作每一类大概1000条数据，训练LSTM的效果如下。</p>
<p> <img src="https://i.loli.net/2021/09/23/nFxqM32AwKhY8I4.png" alt="20210923160403"></p>
<p> <img src="https://i.loli.net/2021/09/23/6TagVw3t1yEWLpG.png" alt="20210923160347"></p>
</li>
<li><p>头部朝向计算</p>
<p>左右耳机的位置可以看成左右耳的位置，但是只知道两个点的坐标没办法计算出头部的朝向。我们知道头部的动作近似是围绕着脖子处的一个轴点进行的，有的动作会导致轴点位置改变（比如前后左右上下移动），而有的动作不会导致轴点位置改变（比如旋转俯仰倾斜）。</p>
<p>在第二步识别出头部动作的基础上，如果是转动类型的动作（旋转，俯仰，倾斜），则轴点不变，如果是移动类型的动作（前后移动，左右移动，上下移动），虽然轴点发生变化了，但是轴点与两耳的相对位置基本可以认为是不变的，所以可以直接根据两耳的位置推算出轴点的位置，这里暂时只考虑了这些简单动作，没考虑复杂的移动，比如低着头移动等。最后根据两耳位置和轴点位置即可得到头部的姿态。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>讨论</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0922</title>
    <url>/2021/09/22/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950922/</url>
    <content><![CDATA[<h2 id="完成LSTM"><a href="#完成LSTM" class="headerlink" title="完成LSTM"></a>完成LSTM</h2><p>numHiddenUnits = 200</p>
<p>maxEpochs = 200</p>
<p>miniBatchSize = 100</p>
<p>rmsprop</p>
<p>‘InitialLearnRate’, 0.001</p>
<p><img src="https://i.loli.net/2021/09/22/vK1PFb24QZMIoW3.png" alt="20210922101444"></p>
<hr>
<p>numHiddenUnits = 200</p>
<p>maxEpochs = 200</p>
<p>miniBatchSize = 100</p>
<p>adam</p>
<p>‘InitialLearnRate’, 0.001</p>
<p><img src="https://i.loli.net/2021/09/22/imF4S7CNlBaMtb2.png" alt="20210922152552"></p>
<hr>
<p>numHiddenUnits = 200</p>
<p>maxEpochs = 200</p>
<p>miniBatchSize = 100</p>
<p>adam</p>
<p>‘InitialLearnRate’, 0.0001</p>
<p><img src="https://i.loli.net/2021/09/22/TeWNc492InFEzZA.png" alt="20210922162306"></p>
<p>（学习率太低了）</p>
<hr>
<p>numHiddenUnits = 200</p>
<p>maxEpochs = 200</p>
<p>miniBatchSize = 50</p>
<p>adam</p>
<p>‘InitialLearnRate’, 0.001</p>
<p>‘LearnRateSchedule’, ‘piecewise’</p>
<p>‘LearnRateDropFactor’, 0.5</p>
<p>‘LearnRateDropPeriod’, 50</p>
<p><img src="https://i.loli.net/2021/09/23/DzHlK7QYUme9pvk.png" alt="20210923190541"></p>
<p>（分段调节的学习率，效果反而不好）</p>
<p>acc = 0.9674</p>
<hr>
<p>numHiddenUnits = 200</p>
<p>maxEpochs = 200</p>
<p>miniBatchSize = 50</p>
<p>adam</p>
<p>‘InitialLearnRate’, 0.001</p>
<p><img src="https://i.loli.net/2021/09/23/jZbsLE6oVDzR2Gc.png" alt="20210923193326"></p>
<p>acc = 0.9801</p>
<hr>
<p>numHiddenUnits = 200</p>
<p>maxEpochs = 200</p>
<p>miniBatchSize = 50</p>
<p>adam</p>
<p>‘InitialLearnRate’, 0.001</p>
<p>‘LearnRateSchedule’, ‘piecewise’</p>
<p>‘LearnRateDropFactor’, 0.5</p>
<p>‘LearnRateDropPeriod’, 100</p>
<p><img src="https://i.loli.net/2021/09/23/iE8cxjKBWTy9OfA.png" alt="20210923195915"></p>
<p>（100epoch之后学习率减半，acc稍微低一点点）</p>
<p>acc = 0.9772</p>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0827</title>
    <url>/2021/08/27/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950827/</url>
    <content><![CDATA[<h2 id="函数重名bug"><a href="#函数重名bug" class="headerlink" title="函数重名bug"></a>函数重名bug</h2><p>workspace输入which strsplit -all查找函数strsplit的地址会发现两条记录：</p>
<p>D:\chrome下载\HMM\HMMall\KPMtools\strsplit.m</p>
<p>D:\MATLAB\R2020a\toolbox\matlab\strfun\strsplit.m  % Shadowed</p>
<p>说明HMM里和toolbox里都有一个名为strsplit的函数，导致函数重名问题。</p>
<p>该bug会在play并且调用hmm时触发，导致程序报错。如果只play采集数据不跑hmm的话不会报错，用已经采集好的数据跑hmm也不会报错。</p>
<p>解决方法是把其中一个工具箱的函数名改掉，但是要找到所有调用该函数的地方改名，暂时还没解决掉。。</p>
<h2 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h2><table>
<thead>
<tr>
<th>数据编号</th>
<th>分类动作</th>
<th>分类编号</th>
</tr>
</thead>
<tbody><tr>
<td>20210827_182636</td>
<td>前后移动</td>
<td>1</td>
</tr>
<tr>
<td>20210827_183214</td>
<td>左右移动</td>
<td>2</td>
</tr>
<tr>
<td>20210827_183657</td>
<td>上下移动</td>
<td>3</td>
</tr>
<tr>
<td>20210827_184027</td>
<td>左右倾斜</td>
<td>4</td>
</tr>
<tr>
<td>20210827_184337</td>
<td>前后俯仰</td>
<td>5</td>
</tr>
<tr>
<td>20210827_184709</td>
<td>左右旋转</td>
<td>6</td>
</tr>
<tr>
<td>20210827_194237</td>
<td>前后移动</td>
<td>1</td>
</tr>
<tr>
<td>20210827_194606</td>
<td>左右移动</td>
<td>2</td>
</tr>
<tr>
<td>20210827_195119</td>
<td>上下移动</td>
<td>3</td>
</tr>
<tr>
<td>20210827_195413</td>
<td>左右倾斜</td>
<td>4</td>
</tr>
<tr>
<td>20210827_195739</td>
<td>前后俯仰</td>
<td>5</td>
</tr>
<tr>
<td>20210827_200120</td>
<td>左右旋转</td>
<td>6</td>
</tr>
<tr>
<td>20210827_200819</td>
<td>前后左右上下（平动）</td>
<td>7</td>
</tr>
<tr>
<td>20210827_201313</td>
<td>倾斜俯仰旋转（转动）</td>
<td>8</td>
</tr>
<tr>
<td>20210827_201808</td>
<td>随意平动</td>
<td>7？</td>
</tr>
<tr>
<td>20210827_202339</td>
<td>随意转动</td>
<td>8？</td>
</tr>
</tbody></table>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>在某些情况下，尤其是移动比较剧烈（比如太左太右或者太高）时，两个定位点会移动到z轴上半轴，比如20210827_183214中后20s的数据。</p>
<p>把每个数据编号都建立一个文件夹应该比较好。</p>
<h2 id="是否可以直接模拟生成数据？"><a href="#是否可以直接模拟生成数据？" class="headerlink" title="是否可以直接模拟生成数据？"></a>是否可以直接模拟生成数据？</h2><p>代码构造一个人头让其移动，记录下来双耳的位置作为数据，这样可以获得大量训练集。</p>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0826</title>
    <url>/2021/08/26/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950826/</url>
    <content><![CDATA[<h2 id="hmm环境配置"><a href="#hmm环境配置" class="headerlink" title="hmm环境配置"></a>hmm环境配置</h2><p>用hmm之前要添加一下地址：addpath(genpath(‘D:\chrome下载\HMM\HMMall’))</p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>提高cal_pos解方程的速度，至少要提高到每秒10帧</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>牛顿迭代就一定会用到雅可比矩阵，雅可比矩阵就一定会用到符号计算，用到符号计算就一定会很慢。。</p>
<p><img src="https://i.loli.net/2021/08/26/TauQpWYhcdfrKGU.png" alt="20210826202638"></p>
<p><img src="https://i.loli.net/2021/08/26/GQZ3nkTUK4odzAr.png" alt="20210826202715"></p>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0825</title>
    <url>/2021/08/25/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950825/</url>
    <content><![CDATA[<h2 id="用HMM完成分类任务"><a href="#用HMM完成分类任务" class="headerlink" title="用HMM完成分类任务"></a>用HMM完成分类任务</h2><p><img src="https://i.loli.net/2021/08/25/XVh9TxvJnpMSRDG.png" alt="20210825170754"></p>
<p>只用了单边位置的数据进行分类，理论上左右发射端的位置是非常对称的。主要是因为HMM的输入好像只能是一维的？</p>
<p>数据长度为10时正确率在90%左右</p>
<p>把数据长度改成20能达到97%的准确率</p>
<p><img src="https://i.loli.net/2021/08/25/oYcQPRKT2wlMpHZ.png" alt="20210825181612"></p>
<p>步长设为5准确率也有96%</p>
<p>但是步长设为10准确率就降到85%zuoyou</p>
<p>步长设为20准确率会降到65%</p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ol>
<li>优化HMM</li>
<li>把HMM训练好的参数保存下来</li>
<li>把HMM和之前的代码结合起来</li>
<li>每次采集数据时要新建一个文件夹</li>
</ol>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0824</title>
    <url>/2021/08/24/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950824/</url>
    <content><![CDATA[<h2 id="采集了6个动作的数据"><a href="#采集了6个动作的数据" class="headerlink" title="采集了6个动作的数据"></a>采集了6个动作的数据</h2><p><img src="https://i.loli.net/2021/08/24/hbB5s1pdzQIYD46.png" alt="20210824223442"></p>
<p>之后把这6组数据的pos算出来，进行轨迹识别。</p>
<h2 id="用HMM对轨迹进行分类"><a href="#用HMM对轨迹进行分类" class="headerlink" title="用HMM对轨迹进行分类"></a>用HMM对轨迹进行分类</h2><p>TODO:</p>
<ol>
<li>把采集到的训练数据的pos计算出来</li>
<li>对数据集进行增强，按照每1秒一段切分（0.9s重叠每个动作大概可以切出1000个数据）</li>
<li>对数据集进行处理，初始位置移动到坐标原点</li>
<li>还可以继续进行数据增强，比如把轨迹进行旋转等</li>
<li>用HMMM训练和分类</li>
</ol>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0823</title>
    <url>/2021/08/23/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950823/</url>
    <content><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ol>
<li><p>提高计算速度。现在每秒只能计算一帧，至少提到每秒10帧。</p>
<ul>
<li>优化解方程</li>
<li>减小帧长，20~40ms</li>
</ul>
</li>
<li><p>用轨迹来判断动作。根据过去3~5s的轨迹来判断当前在做什么动作。</p>
</li>
<li><p>再增加部署2个接收端，一共8个接收端。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0808</title>
    <url>/2021/08/08/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950808/</url>
    <content><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>全部默认为转动，知道耳机中点与轴点的距离超出阈值认为是移动，更新轴点。</p>
<p>俯仰数据：20210808_202031</p>
<p>旋转数据：20210808_202544</p>
<p>倾斜数据：20210808_202641</p>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0807</title>
    <url>/2021/08/08/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950807/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>感觉上面的思路可能想复杂了，可能没必要把动作划分的那么细，应该只要分别出移动和转动就可以了，因为只有移动会导致轴点改变，而转动不会改变轴点位置。</p>
<p>不过也没办法依据一个标准就把移动和转动完全分开，现在想到的比较好的分类标准是“两耳机移动方向是否一致”，根据两耳机移动向量的夹角来判断，如果夹角大于阈值则是旋转yaw和倾斜roll动作，如果夹角小于阈值则是移动或者俯仰pitch，阈值暂定为90度。</p>
<p>所以还需要第二个标准把移动和俯仰分开，目前想用的是“耳机移动方向和视线方向的关系”，因为上下移动和左右移动时是垂直关系，前后移动时是平行关系，只有俯仰既不垂直也不平行，但是这个夹角可能比较小会被误认为平行关系，所以可能会和前后移动混淆。</p>
<p>所以可能还需要再找到一个标准更好地区分前后移动和俯仰，但是这不太好解决，即上面思路的第5点。。。</p>
<p>PS: 后来又发现左右倾斜和左右移动也不好区分。。。“两耳机移动方向是否一致”这个标准好像只能用来区分左右旋转这一个动作。所以可能得考虑用“耳机中点与轴点的距离”，这个标准应该能帮助区分左右倾斜和左右移动以及前后俯仰和前后移动。</p>
<p>思路就是一开始全部认为是转动，一旦距离超过阈值，就认为是移动。</p>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0806</title>
    <url>/2021/08/06/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950806/</url>
    <content><![CDATA[<h2 id="6DoF设计"><a href="#6DoF设计" class="headerlink" title="6DoF设计"></a>6DoF设计</h2><p><img src="https://i.loli.net/2021/08/06/uLwXkANxpcHF6BM.png" alt="20210806110016"></p>
<ol>
<li>forward/backward (surge)：前后移动</li>
<li>left/right (sway)：左右移动</li>
<li>up/down (heave)：上下移动</li>
<li>Roll：左右倾斜</li>
<li>Pitch：前后俯仰</li>
<li>Yaw：左右旋转</li>
</ol>
<p><img src="https://i.loli.net/2021/08/06/ew8XEI2S7PkLbgh.png" alt="20210806104150"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>先把动作分为两类：一类是旋转动作和倾斜动作，另一类是三种平移动作和俯仰动作。</p>
<p> 分类依据：相邻帧两个耳机移动向量的夹角。如果两耳机移动方向不一致（夹角大于阈值）则是第一类动作，如果方向一致（夹角小于阈值）则是第二类动作。</p>
</li>
<li><p>对于第一类动作，如果耳机移动向量与（上一帧）视线方向（几乎）垂直，则是倾斜动作，反之则是旋转动作，或者根据耳机中点是否移动来判断是不是旋转动作。</p>
</li>
<li><p>对于第二类动作，如果耳机移动方向与视线方向几乎垂直，则是左右移动或上下移动；反之则是前后移动或俯仰动作。</p>
</li>
<li><p>对于左右移动或者上下移动，则根据耳机移动向量在竖直方向的分量的绝对值大小来判断，如果在竖直方向的分量占比最大，则是上下移动，反之则是左右移动。</p>
</li>
<li><p>对于前后移动或者俯仰动作，比较难区分，目前想到的方式有</p>
<ol>
<li><p>根据是否有竖直方向的分量来判断，如果有且比较大则是俯仰动作，反之则是前后移动。</p>
</li>
<li><p>根据量耳机中点与轴点的距离来判断（但是这个距离因人而异），如果距离超过固定值则是前后移动，反之则是俯仰动作。</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0805</title>
    <url>/2021/08/05/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950805/</url>
    <content><![CDATA[<h2 id="Pos按钮"><a href="#Pos按钮" class="headerlink" title="Pos按钮"></a>Pos按钮</h2><h3 id="功能：根据距离数据计算前两点坐标pos1和pos2"><a href="#功能：根据距离数据计算前两点坐标pos1和pos2" class="headerlink" title="功能：根据距离数据计算前两点坐标pos1和pos2"></a>功能：根据距离数据计算前两点坐标pos1和pos2</h3><h3 id="输入：dis文件（或者dis-cor文件）"><a href="#输入：dis文件（或者dis-cor文件）" class="headerlink" title="输入：dis文件（或者dis_cor文件）"></a>输入：dis文件（或者dis_cor文件）</h3><h3 id="输出：pos文件（或者pos-cor文件），内部数据每一行nin-nout个值，即每个接收端与每个接口的距离，依次是所有接收端与第一个发射端的距离，所有接收端与第二个发射端的距离"><a href="#输出：pos文件（或者pos-cor文件），内部数据每一行nin-nout个值，即每个接收端与每个接口的距离，依次是所有接收端与第一个发射端的距离，所有接收端与第二个发射端的距离" class="headerlink" title="输出：pos文件（或者pos_cor文件），内部数据每一行nin*nout个值，即每个接收端与每个接口的距离，依次是所有接收端与第一个发射端的距离，所有接收端与第二个发射端的距离"></a>输出：pos文件（或者pos_cor文件），内部数据每一行nin*nout个值，即每个接收端与每个接口的距离，依次是所有接收端与第一个发射端的距离，所有接收端与第二个发射端的距离</h3><h2 id="Dir按钮"><a href="#Dir按钮" class="headerlink" title="Dir按钮"></a>Dir按钮</h2><h3 id="功能：根据前两点坐标pos1和pos2计算第三点坐标pos3和面部朝向dir"><a href="#功能：根据前两点坐标pos1和pos2计算第三点坐标pos3和面部朝向dir" class="headerlink" title="功能：根据前两点坐标pos1和pos2计算第三点坐标pos3和面部朝向dir"></a>功能：根据前两点坐标pos1和pos2计算第三点坐标pos3和面部朝向dir</h3><h3 id="输入：pos文件（或者pos-cor文件）"><a href="#输入：pos文件（或者pos-cor文件）" class="headerlink" title="输入：pos文件（或者pos_cor文件）"></a>输入：pos文件（或者pos_cor文件）</h3><h3 id="输出：dir文件（或者dir-cor文件），内部数据每一行6个数值，依次是pos3的三维坐标，放dir的向量"><a href="#输出：dir文件（或者dir-cor文件），内部数据每一行6个数值，依次是pos3的三维坐标，放dir的向量" class="headerlink" title="输出：dir文件（或者dir_cor文件），内部数据每一行6个数值，依次是pos3的三维坐标，放dir的向量"></a>输出：dir文件（或者dir_cor文件），内部数据每一行6个数值，依次是pos3的三维坐标，放dir的向量</h3>]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>项目</title>
    <url>/2021/08/02/%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="新冠疫情项目"><a href="#新冠疫情项目" class="headerlink" title="新冠疫情项目"></a>新冠疫情项目</h2><ol>
<li><p>距离管控</p>
<p>因为疫情环境下为了避免人们互相传播病毒，所以人数比较多的场合一般都需要人们保持一个最低的社交距离。</p>
<p>假设每个人都随身携带手机，那么可以把手机的位置当做人的位置。</p>
<p>手机开启蓝牙功能，实时搜索环境中的蓝牙信号，根据一些测距算法完成与其他用户的测距，最简单的测距算法比如RSSI或者一些复杂的测距算法。如果测得的距离小于社交距离则提醒用户。</p>
</li>
<li><p>轨迹追踪 –&gt; 密切接触者排查</p>
<p>如果不在环境中部署锚点很难实现绝对的位置测量，但是这个项目的应用场景不一定要实现绝对的轨迹追踪，更重要的是用户都接触过哪些人，所以只需要用蓝牙记录下用户移动过程中搜索到的所有其他蓝牙设备，假设蓝牙设备和用户身份一一对应，那么就可以用这种方式来排查密切接触者。</p>
</li>
</ol>
<h3 id="2021-8-5完成申请书"><a href="#2021-8-5完成申请书" class="headerlink" title="2021/8/5完成申请书"></a>2021/8/5完成申请书</h3>]]></content>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0801</title>
    <url>/2021/08/01/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950801/</url>
    <content><![CDATA[<h2 id="直达径被遮挡问题"><a href="#直达径被遮挡问题" class="headerlink" title="直达径被遮挡问题"></a>直达径被遮挡问题</h2><p>因为发射端是固定在耳机上的，所以直达径很容易被人的头部遮挡。</p>
<p>解决思路是在环境中部署多个接收端，使得不管发射端再什么位置，都有若干个接收端的直达径没有被遮挡。</p>
<h2 id="多接收端定位问题"><a href="#多接收端定位问题" class="headerlink" title="多接收端定位问题"></a>多接收端定位问题</h2><p>因为有多个接收端，而计算发射端位置并不需要这么多接收端。</p>
<p>解决思路是利用GPS的原理，从所有接收端里挑选三个信号最好的用于定位。</p>
<h2 id="信号好坏的判定问题"><a href="#信号好坏的判定问题" class="headerlink" title="信号好坏的判定问题"></a>信号好坏的判定问题</h2><p>人眼可以通过观察cir图主峰是否明显来判定直达径是否被遮挡，但是如何程序化地让计算机来判断。</p>
<p>解决思路是设定一个评价标准，用最高峰的强度除以其它所有点信号强度的平均值，如果这个比值超过一定阈值，则认为该接收端信号直达径没有被遮挡。</p>
<h2 id="多径问题"><a href="#多径问题" class="headerlink" title="多径问题"></a>多径问题</h2><p>在工位上进行实验时，因为发射端和接收端距离比较近以及工位环境比较复杂，所以多径的影响更严重。</p>
<p>解决多径的一个思路是根据发射端当前的位置计算出每一个接收端信号里主峰的理论位置，然后在这个理论位置左右选择一个比较小的区间，在这个区间内选取新的主峰计算距离。</p>
<h2 id="实验记录"><a href="#实验记录" class="headerlink" title="实验记录"></a>实验记录</h2><h3 id="单发射端画了个五角星"><a href="#单发射端画了个五角星" class="headerlink" title="单发射端画了个五角星"></a>单发射端画了个五角星</h3><p><img src="https://i.loli.net/2021/08/01/Ws8wTIt9v3coXrS.png" alt="20210801115343"></p>
<p>数据编号：20210801_114924</p>
<h3 id="戴耳机实验"><a href="#戴耳机实验" class="headerlink" title="戴耳机实验"></a>戴耳机实验</h3><p><img src="https://i.loli.net/2021/08/01/BcmuwXYsUlZG4Wa.png" alt="20210801170105"></p>
<p>数据编号：20210801_170052</p>
<h3 id="六个自由度移动"><a href="#六个自由度移动" class="headerlink" title="六个自由度移动"></a>六个自由度移动</h3><p><img src="https://i.loli.net/2021/08/01/1VdxKW4cjYpECAF.png" alt="20210801190413"></p>
<p>数据编号：20210801_185446</p>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><ol>
<li><p>方向向量朝向问题</p>
<p>已解决。初始化大概的朝向，每次都跟上一个向量做点积，如果小于零则取反。</p>
</li>
<li><p>实验环境的布置问题</p>
<p>现在只有六个接收端，而且是三个对应左发射端三个对应右发射端写死的。要想实现360度旋转可能需要八个接收端，工位每一面都布置两个。然后写一个接收端筛选的算法，使得每个发射端每次都选择三个信号质量最好的接收端。</p>
</li>
<li><p>轴点移动问题</p>
<p>把头部绕脖颈旋转的那个点叫做轴点。因为理论上要判断刚体旋转需要三个点的坐标，但是实验只能获得两个发射端（分别大概在左右耳的位置）的坐标，所以就需要推理出第三个点也就是轴点的坐标。</p>
<p>目前的思路是进行动作划分，把头部动作分为旋转、倾斜、俯仰三个转动动作和前后、左右、上下三个移动动作。</p>
<p>可以发现旋转、倾斜、俯仰这三个转动动作基本不会导致轴点移动，而前后、左右、上下三个移动动作基本必定导致轴点移动，更重要的是在只进行移动动作时，轴点与两个发射点的相对位置保持不变。</p>
<p>所以，如果不考虑复杂动作（转动和移动同时发生）只考虑简单动作（只转动或只移动），对于转动动作可以认为轴点不动，对于移动动作可以根据两个发射点的位置不断计算更新轴点位置。</p>
<p>该思路首先需要对动作进行分类，目前还没想到特别好的分类方法，只能通过两个发射端的移动特征来分类，比如如果左发射点向左下移动右发射点向左上移动，那么这个动作很可能是向左倾斜旋转，所以可以把每个动作导致的发射点的变化列出来作为特征，然后用这些特征来判断是哪个动作。这也是接下来要做事情。</p>
<p>但是这个问题的难点是有些动作很难区分，比如低头和前移，这两个动作反应的特征都是两个发射点前移，只不过低头动作的发射点还会下降，但是对于如果动作幅度很小的话可能比较难判断。</p>
<table>
<thead>
<tr>
<th>动作</th>
<th>特征</th>
</tr>
</thead>
<tbody><tr>
<td>旋转（左）</td>
<td>左点向右后，右点向左前，二者上下不变</td>
</tr>
<tr>
<td>倾斜（左）</td>
<td>左点向左下，右点向左上，二者前后不变</td>
</tr>
<tr>
<td>俯仰（下）</td>
<td>左点向前下，右点向前下，二者左右不变</td>
</tr>
<tr>
<td>前后（前）</td>
<td>左点向前，右点向前，二者左右上下不变</td>
</tr>
<tr>
<td>左右（左）</td>
<td>左点向左，右点向右，二者前后上下不变</td>
</tr>
<tr>
<td>上下（上）</td>
<td>左点向上，右点向上，二者前后左右不变</td>
</tr>
</tbody></table>
<p>（反方向动作特征相反）</p>
<p>分析发现，三类移动动作比较简单，或许可以放到一起讨论？如果左右两点动作特征一样那么就是移动动作（或者俯仰动作），（除俯仰动作外）都可以根据两点位置来更新轴点位置；如果左右特征不一样那么就是转动动作，则认为轴点位置保持不变。</p>
<p>流程：</p>
<ol>
<li><p>左右点特征是否相同？</p>
<ol>
<li>相同。移动动作或者俯仰动作。根据高度是否改变来判断是否为俯仰动作。<ol>
<li>高度改变 –&gt; 俯仰</li>
<li>高度不变 –&gt; 移动动作</li>
</ol>
</li>
<li>不相同。旋转动作。</li>
</ol>
</li>
<li><p>旋转动作时，左右点特征特征？</p>
<ol>
<li>左点向右后，右点向左前 –&gt; 左旋转</li>
<li>左点向右前，右点向左后 –&gt; 右旋转</li>
<li>左点向左下，右点向左上 –&gt; 左倾斜</li>
<li>左点向右上，右点向右下 –&gt; 右倾斜</li>
<li>左点向前下，右点向前下 –&gt; 下俯仰</li>
<li>左点向后上，右点向后上 –&gt; 上俯仰</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0731</title>
    <url>/2021/07/31/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950731/</url>
    <content><![CDATA[<h2 id="不用相位和用相位比较，数据编号：20210722-202008"><a href="#不用相位和用相位比较，数据编号：20210722-202008" class="headerlink" title="不用相位和用相位比较，数据编号：20210722_202008"></a>不用相位和用相位比较，数据编号：20210722_202008</h2><p><img src="https://i.loli.net/2021/07/31/4zMu8SJ3E6gOn7o.png" alt="20210731135923"></p>
<h2 id="在工位上布置实验环境"><a href="#在工位上布置实验环境" class="headerlink" title="在工位上布置实验环境"></a>在工位上布置实验环境</h2><p><img src="https://i.loli.net/2021/07/31/re21tnvmSEgzc4Z.jpg" alt="1100f8c42d289f9bd51c69aa1ee0b88"></p>
<h2 id="空中画圈，数据编号：20210731-160225"><a href="#空中画圈，数据编号：20210731-160225" class="headerlink" title="空中画圈，数据编号：20210731_160225"></a>空中画圈，数据编号：20210731_160225</h2><p><img src="https://i.loli.net/2021/07/31/tgnQixLBmz4kYMh.png" alt="20210731160339"></p>
<h2 id="实时计算并且画cir-dis-pos图时一帧大概需要0-6秒"><a href="#实时计算并且画cir-dis-pos图时一帧大概需要0-6秒" class="headerlink" title="实时计算并且画cir dis pos图时一帧大概需要0.6秒"></a>实时计算并且画cir dis pos图时一帧大概需要0.6秒</h2><p><img src="https://i.loli.net/2021/07/31/W2lPCwUEan3HJ4G.png" alt="20210731163047"></p>
<h2 id="是否使用相位比较"><a href="#是否使用相位比较" class="headerlink" title="是否使用相位比较"></a>是否使用相位比较</h2><p><img src="https://i.loli.net/2021/07/31/ScTqszZluoDk1Bp.png" alt="20210731170010"></p>
<p>上面的是用了相位，下面的没用相位，结果还是没用相位的波动更小一点。</p>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0726</title>
    <url>/2021/07/26/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950726/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/07/26/C2WaSTFlHUcdn9s.png" alt="20210726131049"></p>
<p>突然发现用相位的测距结果反而比不用相位的波动大。。</p>
<p><img src="https://i.loli.net/2021/07/26/sN9Ak6Pz2HLWXFg.png" alt="20210726155435"></p>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0725</title>
    <url>/2021/07/25/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950725/</url>
    <content><![CDATA[<p>20℃<br><img src="https://i.loli.net/2021/07/25/ZCjRvyaxMOSK6pF.png" alt="20210725172935"></p>
<p>26℃<br><img src="https://i.loli.net/2021/07/25/dzCymheBcDvAa3E.png" alt="20210725195329"></p>
<ol>
<li><p>明天可以重测一下发射单和接收端初始的偏移距离，因为修正了一个bug</p>
</li>
<li><p>可能需要找到一个比较好的纠正跳波长问题的算</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0722</title>
    <url>/2021/07/22/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950722/</url>
    <content><![CDATA[<h2 id="实验记录"><a href="#实验记录" class="headerlink" title="实验记录"></a>实验记录</h2><ol>
<li><p>解决了一个BUG，在ZC信号调制时进行共轭对称应该从ofdm的第二个点开始。</p>
<p> <img src="https://i.loli.net/2021/07/22/IEmKOuyUfXCgQkF.png" alt="20210722212743"></p>
<p> 改完的测距记过好像确实好了不少。（数据编号：20210722_170344）（不过rcv6好像坏掉了。。。）</p>
</li>
<li><p>增加了一个test GUI来一对一检测发送或者接收端压电陶瓷是否损坏。</p>
<p> <img src="https://i.loli.net/2021/07/22/TVGfBvDWrPpiYIm.png" alt="20210722212801"></p>
</li>
<li><p> 固定了面部方向；规定了方程组有两个解的时候选哪一个；</p>
</li>
<li><p>头戴耳机静止。数据编号：20210722_200343</p>
<p> <img src="https://i.loli.net/2021/07/22/4s8cPHzvjD6LNgo.png" alt="20210722212810"></p>
</li>
<li><p>左右平移耳机，数据编号：20210722_200840</p>
<p> <img src="https://i.loli.net/2021/07/22/EftCMdxyQ9W8KhL.png" alt="20210722212821"></p>
</li>
<li><p>取消用相位进行细粒度测距，直接用cir进行粗粒度测距，验证一下相位的作用。数据编号：20210722_202008<br> 只用cir</p>
<p> <img src="https://i.loli.net/2021/07/22/P51Nfhy2EdaIBjK.png" alt="20210722212827"></p>
<p> 用相位以后</p>
<p> <img src="https://i.loli.net/2021/07/22/ECfWrhUvod59AJy.png" alt="20210722212839"></p>
<p> 咋感觉增加相位以后测距效果更差了？？？</p>
<p> 改成26℃</p>
<p> <img src="https://i.loli.net/2021/07/22/4hYfq67PNvjdJzF.png" alt="20210722212848"></p>
<p> 改变正负号</p>
<p> <img src="https://i.loli.net/2021/07/22/4tvemFZEQ3Huins.png" alt="20210722212855"></p>
</li>
<li><p>增加一个单选按钮用来显示当前计算需要的数据是否已经读入，如果读入了就不用再重新读取。如果更改数据编号则需要重新读取，但是如果是因为播放录制而导致的数据编号改变则不需要重新读取数据。</p>
<p> <img src="https://i.loli.net/2021/07/23/1kahuU2plFfbPc9.png" alt="20210723135441"></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0721</title>
    <url>/2021/07/22/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950721/</url>
    <content><![CDATA[<p>数据编号：20210720_213700</p>
<p><img src="https://i.loli.net/2021/07/22/VKnY97UIrLThoHc.png" alt="20210722141029"></p>
<p>修正后</p>
<p><img src="https://i.loli.net/2021/07/22/xMIkXEhKTG65AHL.png" alt="20210722141053"></p>
<p>可能是跳波长？接下来试一下整个波长纠正。</p>
<p>温度影响？？</p>
<p>温度试验：<br>原始20℃</p>
<p><img src="https://i.loli.net/2021/07/22/VKnY97UIrLThoHc.png" alt="20210722141101"></p>
<p>21℃</p>
<p><img src="https://i.loli.net/2021/07/22/pqUTtlKR9OubAHF.png" alt="20210722141109"></p>
<p>22℃</p>
<p><img src="https://i.loli.net/2021/07/22/Oe9u6VrzXsy3SIE.png" alt="20210722141116"></p>
<p>23℃</p>
<p><img src="https://i.loli.net/2021/07/22/Zi81MxudVgSLRAt.png" alt="20210722141124"></p>
<p>24℃</p>
<p><img src="https://i.loli.net/2021/07/22/dxy4bTGmwlJ8FUZ.png" alt="20210722141130"></p>
<p>25℃</p>
<p><img src="https://i.loli.net/2021/07/22/qlFgUY5hkZN69BC.png" alt="20210722141137"></p>
<p>30℃</p>
<p><img src="https://i.loli.net/2021/07/22/CASwHeqh1BKzPOQ.png" alt="20210722141145"></p>
<p>50℃</p>
<p><img src="https://i.loli.net/2021/07/22/BKw7HqE1GldLUkO.png" alt="20210722141212"></p>
<p>100℃</p>
<p><img src="https://i.loli.net/2021/07/22/rN678mecnyqWXxQ.png" alt="20210722141227"></p>
<p>感觉就是图像整体平移了呀，这有点儿不合理，是不是代码写的有问题？？  </p>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0720</title>
    <url>/2021/07/20/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950720/</url>
    <content><![CDATA[<h2 id="测距的锯齿问题"><a href="#测距的锯齿问题" class="headerlink" title="测距的锯齿问题"></a>测距的锯齿问题</h2><p><img src="https://i.loli.net/2021/07/20/qcRVyKobepILfw8.png" alt="20210720103532"></p>
<p><img src="https://i.loli.net/2021/07/20/vpi5AmwbPxCdkfZ.png" alt="20210720103650"></p>
<h2 id="存在的问题："><a href="#存在的问题：" class="headerlink" title="存在的问题："></a>存在的问题：</h2><ol>
<li><p>ai1对应的压电陶瓷接收端采集的数据计算出来的距离波动总是比其他的大。</p>
<p> <img src="https://i.loli.net/2021/07/20/z2yomi4XgdFQZnu.png" alt="20210720215558"></p>
</li>
<li><p>发射端追踪还是不够准确</p>
<p> <img src="https://i.loli.net/2021/07/20/oU9aDwK2kSrsHCL.png" alt="20210720215605"></p>
<p> 数据编号：20210720_164407</p>
</li>
</ol>
<h2 id="要做的事："><a href="#要做的事：" class="headerlink" title="要做的事："></a>要做的事：</h2><ol>
<li><p>解决ai1接收端数据波动大的问题。</p>
<p> 把ai0和ai1的插头交换之后，还是ai1对应的数据波动大，说明可能是ai1这个接口有问题。（数据编号：20210720_165731）</p>
<p> 把ai1换成ai3之后，数据波动就没那么大，所以证明应该是ai1这个接口有问题，以后左边使用ai0 ai3 ai2这三个接口。（数据编号：20210720_170841）</p>
<p> <img src="https://i.loli.net/2021/07/20/ETsHDiQmVUM6k3K.png" alt="20210720215634"></p>
</li>
<li><p> 增加一个功能，使得在gui界面上能够选择是用原始距离定位还是用修正后的距离定位。</p>
</li>
</ol>
<h2 id="实验记录："><a href="#实验记录：" class="headerlink" title="实验记录："></a>实验记录：</h2><ol>
<li><p>切换端口后的实验。.把ai1换到ai3上，解决了ai1计算的距离波动大的问题。</p>
<p> <img src="https://i.loli.net/2021/07/20/hFQiMf3m67IvCsd.png" alt="20210720215659"></p>
<p> 数据编号：20210720_171347</p>
</li>
<li><p> 增加了两个单选按钮，实现可以在gui界面上选择用原始距离还是修正距离来计算位置。</p>
</li>
<li><p> 测量了房间的长度，大概是3.865m</p>
</li>
<li><p>头戴耳机进行了实验，数据编号：20210720_213700。</p>
<p> <img src="https://i.loli.net/2021/07/20/z9DZd6l7x8GLXmO.png" alt="20210720215715"></p>
</li>
</ol>
<h2 id="存在的问题：-1"><a href="#存在的问题：-1" class="headerlink" title="存在的问题："></a>存在的问题：</h2><ol>
<li><p>接收端离得太远会导致测距结果不精准，波动大。</p>
<p> 还可以增大电压么？</p>
<p> 或者不放那么远，不在会议室做就在工位上做？</p>
</li>
<li><p> 画向量图的时候2D视图里向量跟三角形面不垂直。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0719</title>
    <url>/2021/07/19/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950719/</url>
    <content><![CDATA[<ol>
<li><p>单个发射端追踪</p>
<p><img src="https://i.loli.net/2021/07/19/ueZhVL2g8X1Wfon.png" alt="20210719194903"></p>
<p>效果一般吧，感觉误差有个一两厘米的样子。</p>
</li>
<li><p>有个接收端好像坏了，ai7？</p>
<p>解决了，不是接收端坏了，是线接错了，应该右边三个应该接ai4 ai5 ai6三个接口。</p>
</li>
<li><p>把采集数据，测距，定位三个功能独立开了，每个按钮只负责一个功能。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0718</title>
    <url>/2021/07/18/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950718/</url>
    <content><![CDATA[<p>好像找到方程组无解的原因了，应该是因为三个接收端在同一条直线上了。需要重新布置一下实验环境，让三个压电陶瓷不在同一条直线上。</p>
<p><img src="https://i.loli.net/2021/07/18/UTolOQvcKEqmxWy.png" alt="20210718163148"></p>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0717</title>
    <url>/2021/07/17/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950717/</url>
    <content><![CDATA[<p>重写了一下计算位置解方程的代码，目前距离能测出来，但是位置解不出来，方程组无解。<br>数据编号：20210717_213221</p>
<p><img src="https://i.loli.net/2021/07/17/CY8cOrpKDBnjQ2J.png" alt="20210717213808"></p>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0716</title>
    <url>/2021/07/16/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950716/</url>
    <content><![CDATA[<h2 id="收发压电陶瓷之间的初始距离校准。（0距离，ni一次开关机之内）"><a href="#收发压电陶瓷之间的初始距离校准。（0距离，ni一次开关机之内）" class="headerlink" title="收发压电陶瓷之间的初始距离校准。（0距离，ni一次开关机之内）"></a>收发压电陶瓷之间的初始距离校准。（0距离，ni一次开关机之内）</h2><p>第一次：</p>
<p><img src="https://i.loli.net/2021/07/16/DuXb7k3BvVjoSc2.png" alt="20210716214323"></p>
<p>第二次：</p>
<p><img src="https://i.loli.net/2021/07/16/azQ7fECqN5jghSm.png" alt="20210716214334"></p>
<p>第三次：</p>
<p><img src="https://i.loli.net/2021/07/16/KTewuZ95G8ogvhU.png" alt="20210716214341"></p>
<p>第四次：</p>
<p><img src="https://i.loli.net/2021/07/16/iBpUYoDgnNzmOZV.png" alt="20210716214347"></p>
<p>第五次：</p>
<p><img src="https://i.loli.net/2021/07/16/GQzPHt7xDsbcRUJ.png" alt="20210716214358"></p>
<h2 id="重启ni"><a href="#重启ni" class="headerlink" title="重启ni"></a>重启ni</h2><p>第一次：</p>
<p><img src="https://i.loli.net/2021/07/16/xA9NMPXqIGDL5H3.png" alt="20210716214416"></p>
<p>第二次：（改为4位小数）20210716_183142</p>
<p><img src="https://i.loli.net/2021/07/16/24ZOU9ghJBuskXj.png" alt="20210716214444"></p>
<p>第三次：20210716_183419</p>
<p><img src="https://i.loli.net/2021/07/16/aplKXykWM9Ds7Y5.png" alt="20210716214449"></p>
<p>第四次：20210716_183719<br>0.0690 0.0697 0.0599 100.0000 100.0000 100.0000 \n100.0000 100.0000 100.0000 0.1098 0.0669 0.0582 \n</p>
<p>第五次：20210716_184007<br>0.0609 0.0699 0.0605 100.0000 100.0000 100.0000 \n100.0000 100.0000 100.0000 0.0844 0.0583 0.0340 \n</p>
<p>第六次：20210716_184252<br>0.0607 0.0693 0.0605 100.0000 100.0000 100.0000 \n100.0000 100.0000 100.0000 0.1125 0.0582 0.0250 \n</p>
<p>第七次：20210716_184453<br>0.0689 0.0698 0.0606 100.0000 100.0000 100.0000 \n100.0000 100.0000 100.0000 0.1097 0.0685 0.0532 \n</p>
<p>第八次：20210716_184719<br>0.0688 0.0691 0.0593 100.0000 100.0000 100.0000 \n100.0000 100.0000 100.0000 0.1267 0.0680 0.0524 \n</p>
<p>第九次：20210716_184812<br>0.0688 0.0695 0.0607 100.0000 100.0000 100.0000 \n100.0000 100.0000 100.0000 0.1267 0.0680 0.0356 \n</p>
<p>第十次：20210716_184924<br>0.0691 0.0694 0.0608 100.0000 100.0000 100.0000 \n100.0000 100.0000 100.0000 0.1279 0.0689 0.0441 \n</p>
<p>基本都保持在0.069 0.069 0.060这个值附近</p>
<h2 id="重启ni-1"><a href="#重启ni-1" class="headerlink" title="重启ni"></a>重启ni</h2><p>第一次：20210518_193646<br>0.0691 0.0689 0.0608 100.0000 100.0000 100.0000 \n100.0000 100.0000 100.0000 0.1098 0.0350 0.0341 \n</p>
<p>第二次：20210716_185353<br>0.0611 0.0691 0.0606 100.0000 100.0000 100.0000 \n100.0000 100.0000 100.0000 0.1023 0.0606 0.0344 \n</p>
<p>第三次：20210716_185537<br>0.0695 0.0693 0.0605 100.0000 100.0000 100.0000 \n100.0000 100.0000 100.0000 0.1035 0.0667 0.0413 \n</p>
<p>第四次：20210716_185756<br>0.0692 0.0693 0.0603 100.0000 100.0000 100.0000 \n100.0000 100.0000 100.0000 0.1199 0.0621 0.0443 \n</p>
<p>第五次：20210716_185928<br>0.0692 0.0694 0.0604 100.0000 100.0000 100.0000 \n100.0000 100.0000 100.0000 0.1114 0.0677 0.0431 \n</p>
<p>基本也都保持在0.069 0.069 0.060这个值附近，不过会出现跳一个波长的问题，所以很可能这三个接收端的数值也是一样的，因为0.069和0.060也刚好差不多差了一个波长。</p>
<p>所以只要保证设备（包括ni，线，电脑等）不变，这个初始校准距离很可能是个定值，如果是这样的话，那么就能保证对于一套设备只需要一开始做一次校准即可，之后的使用都不需要重新校准了。</p>
<h2 id="重启ni-2"><a href="#重启ni-2" class="headerlink" title="重启ni"></a>重启ni</h2><p>第一次：20210716_190345<br>0.0691 0.0692 0.0525 100.0000 100.0000 100.0000 \n100.0000 100.0000 100.0000 0.0848 1.8292 2.0417 \n</p>
<p>第二次：20210716_202732<br>0.0690 0.0689 0.0606 100.0000 100.0000 100.0000 \n100.0000 100.0000 100.0000 0.0678 0.0678 2.0502 \n</p>
<p>第三次：20210716_202822<br>0.0687 0.0690 0.0607 100.0000 100.0000 100.0000 \n100.0000 100.0000 100.0000 1.5989 1.8281 0.0274 \n</p>
<p>换成长线（1m-&gt;3m）<br>第四次：20210716_202911<br>0.0688 0.0691 0.0605 100.0000 100.0000 100.0000 \n100.0000 100.0000 100.0000 0.0765 0.0344 2.0525 \n</p>
<p>第五次：20210716_203059<br>0.0687 0.0694 0.0606 100.0000 100.0000 100.0000 \n100.0000 100.0000 100.0000 0.0754 1.8191 100.0000 \n</p>
<p>结论：线的长度影响不大</p>
<p>开始测量右边三个接收端（ai4 ai5 ai6）<br>第六次：20210716_203540<br>1.1691 100.0000 0.7213 100.0000 100.0000 100.0000 \n100.0000 100.0000 100.0000 0.0759 0.0265 0.0695 \n</p>
<p>第七次：20210716_20375<br>1.0651 100.0000 0.6266 100.0000 100.0000 100.0000 \n100.0000 100.0000 100.0000 0.0778 0.0687 0.0758 \n</p>
<p>第八次：20210716_204044<br>1.0719 100.0000 0.6267 100.0000 100.0000 100.0000 \n100.0000 100.0000 100.0000 0.0774 0.0609 0.0754 \n</p>
<p>第九次：20210716_204213<br>1.0636 100.0000 0.6348 100.0000 100.0000 100.0000 \n100.0000 100.0000 100.0000 0.0778 0.0694 0.0757 \n</p>
<p>第十次：20210716_204339<br>1.0711 100.0000 0.6345 100.0000 100.0000 100.0000 \n100.0000 100.0000 100.0000 0.0764 0.0607 0.0696 \n</p>
<p>第十一次：20210716_204513<br>1.0749 100.0000 0.6256 100.0000 100.0000 100.0000 \n100.0000 100.0000 100.0000 0.0695 0.0692 0.0773 \n</p>
<p>右边三个接收端的初始校准距离大概是0.077 0.069 0.075左右</p>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0715</title>
    <url>/2021/07/15/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950715/</url>
    <content><![CDATA[<ol>
<li><p>今天主要在623会议室部署了一下实验环境。在相距大概4m的两面墙上各贴了3个接收端，间距30cm。</p>
<p> <img src="https://i.loli.net/2021/07/16/MlDItB8aRZwxYij.jpg" alt="IMG_20210715_203920"></p>
<p> <img src="https://i.loli.net/2021/07/16/Of9enLNKuxArFyw.jpg" alt="IMG_20210715_203904"></p>
<p> <img src="https://i.loli.net/2021/07/16/EObTv9SfK8BG7WR.jpg" alt="IMG_20210715_203916"></p>
</li>
<li><p>用耳机上的两个发射端测试了一下，感觉距离在1m~1.5m左右效果更好一点，这两面墙的间距可能稍微大了一点儿，有的时候离得远的接收端信号不稳定。</p>
<p> <img src="https://i.loli.net/2021/07/15/EhBS1JING6Lstzp.png" alt="20210715211332"></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0714</title>
    <url>/2021/07/14/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950714/</url>
    <content><![CDATA[<ol>
<li><p>测了一下压电陶瓷超声信号的传播距离，两三米肯定是没什么问题，而且发现一个现象就是距离越远反而信号质量越高，即cir主峰更明显旁瓣更弱，感觉可能是因为多径的其他反射信号比较弱，距离远了这些反射信号衰减比较厉害，只留下直达径的信号。所以感觉可以把接收端的部署范围扩大一点，没必要只安装在工位这么小的区域上，其实可以找个会议室安装地远一点。</p>
<p><img src="https://i.loli.net/2021/07/14/MxeuEZUHsp865Bm.png" alt="20210714165454"></p>
</li>
<li><p>目前的思路是在一个屋子内部署多个接收端，然后借鉴GPS卫星定位的思路，即确保每个发射端再任何位置都至少能和三个（或者四个？）接收端之间的直达径不被遮挡。</p>
</li>
<li><p>接下来要做的事：</p>
<ol>
<li>找一个空会议室，目前感觉623可以。</li>
<li>在会议室内布置6个压电陶瓷接收端，目前好像只能给他粘到墙上，要是有架子什么的可能会好一点。</li>
<li>把两个压电陶瓷发射端粘到耳机上，先粘到耳机侧面试试。</li>
<li>ni设备分配的时间是二四六白天和一三五晚上，所以上述部署好之后需要每次把ni和笔记本搬到623做实验。</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0713</title>
    <url>/2021/07/13/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950713/</url>
    <content><![CDATA[<h2 id="challenge："><a href="#challenge：" class="headerlink" title="challenge："></a>challenge：</h2><ol>
<li>多个接收端的固定问题。固定在哪里？可能需要一个架子。</li>
<li>实验开始之前需要初始化一个接收端和发射端的位置，这个可能需要每次都重新测量一下，但这样太麻烦了，而且要精确测量压电陶瓷在空间中的位置好像并不容易。</li>
<li>没有办法自动初始化的原因是，虽然接收端和发射端在同一个同源的设备上，但是还是存在一个偏差，就是即使把接收端和发射端贴到一起测得的距离也大概有0.07m左右。</li>
<li>从多个接收端中挑选三个信号比较好的来定位，即如何找出直达径没有被遮挡？肉眼可以通过观察cir图有没有明显的主峰来判断，但是让计算机去判断可能需要一个评判标准，比如最高峰与其他所有点的均值的比值等等。</li>
<li>用三个没有被遮挡的接收端的信号计算出三个距离来解算出两个发射端的位置，两个发射端的位置只代表了人双耳的位置，怎么用这两个坐标的追踪完成对头部运动的追踪。如果假定身子不动的话，那么只能完成三个自由度，即旋转、俯仰和倾斜，然而实际上人不可能保持身体完全不动。那么如何只用两个点完成六个自由度的追踪呢？</li>
</ol>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0707</title>
    <url>/2021/07/07/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950707/</url>
    <content><![CDATA[<p>存在的问题：</p>
<ol>
<li>直达径被遮挡之后cir图会变得很乱，很难进行分析。<br><img src="https://i.loli.net/2021/07/07/p3QoSw17JTDIyR9.png" alt="20210707121459"></li>
<li>信号换成fmcw之后接收到的信号很弱。<br><img src="https://i.loli.net/2021/07/07/QsV8wdJFOy3nf4t.png" alt="20210707121540"></li>
</ol>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0518</title>
    <url>/2021/05/18/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950518/</url>
    <content><![CDATA[<p>进展：</p>
<ol>
<li>初步实现了头部方向的追踪</li>
</ol>
<p>问题：</p>
<ol>
<li>只有三个自由度（旋转、俯仰、倾斜），六自由度（再加上前后、左右、上下的移动）实现不了，因为目标上只有两个发射端，通过对这两个发射端的追踪再加上一个头部的不动点最多只能实现三个自由度的追踪。</li>
<li>目前实验还比较粗糙，发射端和接收端的放置可能不准确，尤其是每次实验都需要初始化一下两个发射端再三维空间中的位置，我现在都是大概估计的，没办法准确确定其位置。而且目前没有把发射端压电陶瓷粘到耳机上做实验，只是把发射端粘在纸板上做实验，因为粘到耳机上实验时就更难初始化其位置了。</li>
<li>目前实验的展示效果不好，只是用matlab画3D和2D画图，而且只是用两个发射端的点和一个固定点组成的三角形来代表头部旋转，可能需要一个真实头部的三维建模看起会好一些？比如unity之类的游戏引擎。</li>
<li>目前的实验还没有groundtruth。<br><img src="https://i.loli.net/2021/05/18/nuvky9io3SgDCje.png" alt="20210518210854"></li>
</ol>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>git报错10054</title>
    <url>/2021/05/02/git%E6%8A%A5%E9%94%9910054/</url>
    <content><![CDATA[<h2 id="Git-Push时报错-Connection-was-reset-errno-10054"><a href="#Git-Push时报错-Connection-was-reset-errno-10054" class="headerlink" title="Git Push时报错 Connection was reset, errno 10054"></a>Git Push时报错 Connection was reset, errno 10054</h2><p><img src="https://raw.githubusercontent.com/Jepson-Song/images/master/20210502110023.png" alt="20210502110023"></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>git config –global –unset-all remote.origin.proxy</p>
<h2 id="smms图床"><a href="#smms图床" class="headerlink" title="smms图床"></a>smms图床</h2><p><img src="https://i.loli.net/2021/05/02/mpuaDew8O7jF9qh.png" alt="20210502115036"></p>
]]></content>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0427</title>
    <url>/2021/04/27/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950427/</url>
    <content><![CDATA[<p>现象：</p>
<ol>
<li>cir图大致看起还可以</li>
<li>跳2pi导致的距离波动非常严重</li>
</ol>
<p>下一步尝试的方向：</p>
<ol>
<li>用双耳距离来纠跳2pi的问题</li>
<li>zc+单频连续波的思路</li>
</ol>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0426</title>
    <url>/2021/04/26/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950426/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/Jepson-Song/images/master/20210426162158.png" alt="20210426162158"></p>
<p>存在的问题：</p>
<ol>
<li>跳2pi</li>
<li>压电陶瓷的朝向对cir影响很大</li>
</ol>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0420</title>
    <url>/2021/04/20/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950420/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/Jepson-Song/images/master/20210420212718.png" alt="20210420212718"></p>
<p><img src="https://raw.githubusercontent.com/Jepson-Song/images/master/20210420212742.png" alt="20210420212742"></p>
<p><img src="https://raw.githubusercontent.com/Jepson-Song/images/master/20210420213237.png" alt="20210420213237"></p>
<p>慢速移动时会出现跳变，快速移动时就没有，跳变的大小很像是一个波长</p>
<p><img src="https://raw.githubusercontent.com/Jepson-Song/images/master/20210420214655.png" alt="20210420214655"></p>
<p>中心频率是30k，波长大概是1.1447~=1.15cm</p>
<p><img src="https://raw.githubusercontent.com/Jepson-Song/images/master/20210420215800.png" alt="20210420215800"></p>
<hr>
<p>把取整函数从floor改成fix之后<br><img src="https://raw.githubusercontent.com/Jepson-Song/images/master/20210420221810.png" alt="20210420221810"></p>
<p><img src="https://raw.githubusercontent.com/Jepson-Song/images/master/20210420222115.png" alt="20210420222115"></p>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>实验记录0414</title>
    <url>/2021/04/14/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950414/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/Jepson-Song/images/master/20210414213909.png" alt="20210414213909"><br>偶尔出现的，两个都好像是对的</p>
<p><img src="https://raw.githubusercontent.com/Jepson-Song/images/master/20210414215908.png" alt="20210414215908"><br>273 3 4 </p>
<p><img src="https://raw.githubusercontent.com/Jepson-Song/images/master/20210414220040.png" alt="20210414220040"><br>273 15 13</p>
<p><img src="https://raw.githubusercontent.com/Jepson-Song/images/master/20210414220124.png" alt="20210414220124"><br>253 15 13</p>
]]></content>
  </entry>
  <entry>
    <title>实验记录0413</title>
    <url>/2021/04/13/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%950413/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/Jepson-Song/images/master/20210413202855.png" alt="20210413202855"><br>低频部分信号很弱，噪声很多</p>
]]></content>
      <tags>
        <tag>实验记录</tag>
      </tags>
  </entry>
  <entry>
    <title>七层网络模型</title>
    <url>/2021/04/13/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/Jepson-Song/images/master/20210413144030.png" alt="20210413144030"></p>
<p>从下往上</p>
<ul>
<li>物理层</li>
<li>数据链路层</li>
<li>网络层</li>
<li>传输层</li>
<li>会话层</li>
<li>表示层</li>
<li>应用层</li>
</ul>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>虚函数</title>
    <url>/2021/04/13/%E8%99%9A%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是在不同继承关系的类对象，去调同一函数，产生了不同的行为。</p>
<p>就是说，有一对继承关系的两个类，这两个类里面都有一个函数且名字、参数、返回值均相同，然后我们通过调用函数来实现不同类对象完成不同的事件。</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>在main函数中，如果有父类或者子类的实例对象，就需要有父类的虚函数的实现；在main函数中，如果没有父类或者子类的实例对象，可以不实现父类的虚函数。</p>
<p>虚函数的目的是为了(在继承中)实现多态 。每一个类都有一个虚函数表(v-table)，每个对象都有一个虚函数指针(vptr)，指向虚函数表。当子类对象被创建后，虚函数指针就会指向子类中覆盖的虚函数。当使用基类指针时，虚函数指针将根据基类指针指向的对象的实际类型，来指向正确的函数。</p>
<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>子类必须实现该函数（接口）</p>
<p>有纯虚函数的类叫做抽象类，不能生成实例对象</p>
<p>抽象类就像一个规范一样，like 接口(Interface) in Java</p>
<h2 id="虚函数与纯虚函数"><a href="#虚函数与纯虚函数" class="headerlink" title="虚函数与纯虚函数"></a>虚函数与纯虚函数</h2><p>定义一个函数为虚函数，不代表函数为不被实现的函数。</p>
<p>定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。</p>
<p>定义一个函数为纯虚函数，才代表函数没有被实现。</p>
<p>定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</p>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>sort和qsort</title>
    <url>/2021/04/10/sort%E5%92%8Cqsort/</url>
    <content><![CDATA[<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b;<span class="comment">//从大到小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, cmp);</span><br></pre></td></tr></table></figure>

<h2 id="qsort"><a href="#qsort" class="headerlink" title="qsort"></a>qsort</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *(<span class="keyword">int</span>*)b - *(<span class="keyword">int</span>*)a;<span class="comment">//从大到小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">qsort</span>(a+<span class="number">1</span>, n, <span class="built_in"><span class="keyword">sizeof</span></span>(a[<span class="number">0</span>]),cmp2);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2021/04/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mysort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">	mysort(l, mid);</span><br><span class="line">	mysort(mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = l;</span><br><span class="line">	<span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> k = l;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;</span><br><span class="line">			b[k++] = a[i++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			b[k++] = a[j++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">		b[k++] = a[i++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= r) &#123;</span><br><span class="line">		b[k++] = a[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> t = l; t &lt;= r; t++) &#123;</span><br><span class="line">		a[t] = b[t];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mysort2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> i = l;</span><br><span class="line">	<span class="keyword">int</span> j = r;</span><br><span class="line">	<span class="keyword">int</span> flag = a[i];</span><br><span class="line">	<span class="keyword">while</span> (i&lt;j) &#123;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; j &amp;&amp; flag &lt;= a[j]) &#123;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		a[i] = a[j];</span><br><span class="line">		<span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= flag) &#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		a[j] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	a[i] = flag;</span><br><span class="line">	mysort2(l, i);</span><br><span class="line">	mysort2(i + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>github图片看不了</title>
    <url>/2021/04/08/github%E5%9B%BE%E7%89%87%E7%9C%8B%E4%B8%8D%E4%BA%86/</url>
    <content><![CDATA[<h2 id="改host"><a href="#改host" class="headerlink" title="改host"></a>改host</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">140.82.113.3      github.com</span><br><span class="line">140.82.114.20     gist.github.com</span><br><span class="line"></span><br><span class="line">151.101.184.133    assets-cdn.github.com</span><br><span class="line">151.101.184.133    raw.githubusercontent.com</span><br><span class="line">151.101.184.133    gist.githubusercontent.com</span><br><span class="line">151.101.184.133    cloud.githubusercontent.com</span><br><span class="line">151.101.184.133    camo.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars0.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars0.githubusercontent.com</span><br><span class="line">199.232.28.133     avatars1.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars1.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars2.githubusercontent.com</span><br><span class="line">199.232.28.133     avatars2.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars3.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars3.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars4.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars4.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars5.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars5.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars6.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars6.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars7.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars7.githubusercontent.com</span><br><span class="line">151.101.184.133    avatars8.githubusercontent.com</span><br><span class="line">199.232.68.133     avatars8.githubusercontent.com</span><br></pre></td></tr></table></figure>

<h2 id="改DNS"><a href="#改DNS" class="headerlink" title="改DNS"></a>改DNS</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">233.5.5.5</span><br><span class="line">233.6.6.6</span><br></pre></td></tr></table></figure>

<h2 id="结果都没用"><a href="#结果都没用" class="headerlink" title="结果都没用"></a>结果都没用</h2>]]></content>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>快排</title>
    <url>/2021/04/08/%E5%BF%AB%E6%8E%92/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mysort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> tl = l;</span><br><span class="line">    <span class="keyword">int</span> tr = r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag = nums[l];</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;flag&lt;=nums[r])&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[l] = nums[r];</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[l]&lt;=flag)&#123;</span><br><span class="line">            l ++;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[r] = nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[l] = flag;</span><br><span class="line"></span><br><span class="line">    mysort(nums, tl, l<span class="number">-1</span>);</span><br><span class="line">    mysort(nums, l+<span class="number">1</span>, tr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>端口转发</title>
    <url>/2021/04/08/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/Jepson-Song/images/master/20210408172946.png" alt="20210408172946"></p>
]]></content>
  </entry>
  <entry>
    <title>单调栈</title>
    <url>/2021/04/08/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">    rightMin[i] = len;       </span><br><span class="line">    <span class="keyword">while</span>(!que.empty()&amp;&amp;heights[que.top()]&gt;heights[i])&#123;</span><br><span class="line">        rightMin[que.top()] = i;</span><br><span class="line">        que.pop();</span><br><span class="line">    &#125;    </span><br><span class="line">    que.push(i);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo常用命令</title>
    <url>/2021/04/08/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul>
<li>hexo n “我的博客” == hexo new “我的博客” #新建文章</li>
<li>hexo p == hexo publish</li>
<li>hexo g == hexo generate#生成</li>
<li>hexo s == hexo server #启动服务预览</li>
<li>hexo d == hexo deploy#部署</li>
</ul>
<h3 id="多个tags用方括号括起来，并用逗号分隔"><a href="#多个tags用方括号括起来，并用逗号分隔" class="headerlink" title="多个tags用方括号括起来，并用逗号分隔"></a>多个tags用方括号括起来，并用逗号分隔</h3>]]></content>
      <tags>
        <tag>教程</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建Hexo博客</title>
    <url>/2021/03/29/%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="安装配置Hexo"><a href="#安装配置Hexo" class="headerlink" title="安装配置Hexo"></a>安装配置Hexo</h2><ul>
<li>环境安装，nodejs + git，Hexo使用npm来进行包管理的；</li>
<li>安装hexo脚手架：cnpm install hexo-cli；</li>
<li>初始化博客文件：hexo init my_first_blog；</li>
<li>常用命令<ul>
<li>清理：hexo clean</li>
<li>生成：hexo g</li>
<li>部署：hexo d</li>
<li>启动本地服务：hexo s</li>
</ul>
</li>
<li>打开本地博客 localhost:4000；</li>
</ul>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>使用hexo d来部署时可能会出现这种部署失败的问题<br><img src="https://raw.githubusercontent.com/Jepson-Song/images/master/20210329154940.png" alt="20210329154940"></p>
<h3 id="解决方法1"><a href="#解决方法1" class="headerlink" title="解决方法1"></a>解决方法1</h3><ol>
<li>删掉.deploy_git文件夹</li>
<li>依次运行hexo clean，hexo g，hexo d</li>
</ol>
<h3 id="解决方法2"><a href="#解决方法2" class="headerlink" title="解决方法2"></a>解决方法2</h3><p>直接使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d命令<br><img src="https://raw.githubusercontent.com/Jepson-Song/images/master/20210329213357.png" alt="20210329213357"></p>
<h3 id="解决方法3（成功）"><a href="#解决方法3（成功）" class="headerlink" title="解决方法3（成功）"></a>解决方法3（成功）</h3><p>把博客部署的网址从http换成git</p>
]]></content>
      <tags>
        <tag>教程</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>testPic</title>
    <url>/2021/03/29/testPic/</url>
    <content><![CDATA[<h1 id="this-is-a-test-for-picture"><a href="#this-is-a-test-for-picture" class="headerlink" title="this is a test for picture"></a>this is a test for picture</h1><p><img src="https://raw.githubusercontent.com/Jepson-Song/images/master/20210329152430.png" alt="20210329152430"></p>
]]></content>
  </entry>
  <entry>
    <title>test2</title>
    <url>/2021/03/29/test2/</url>
    <content><![CDATA[<h1 id="this-is-test2"><a href="#this-is-test2" class="headerlink" title="this is test2"></a>this is test2</h1>]]></content>
  </entry>
  <entry>
    <title>test</title>
    <url>/2021/03/29/test/</url>
    <content><![CDATA[<h1 id="this-is-a-test"><a href="#this-is-a-test" class="headerlink" title="this is a test"></a>this is a test</h1>]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/03/29/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
